<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÌÅ¨Î°úÎÖ∏ Î∏åÎ†àÏù¥ÌÅ¨</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d1a; --player-color: #00ffff;
            --enemy-color-1: #ff4d4d; --enemy-color-2: #ffcc00; --enemy-dasher-color: #f0a050; --enemy-weaver-color: #9d74e0; --enemy-kamikaze-color: #ffffff; --boss-color: #ff00ff;
            --enemy-sentinel-color: #c0c0c0; --enemy-bulwark-color: #708090; --enemy-barrier-color: #4682b4;
            --enemy-bullet-color: #ff80ff;
            --powerup-p-color: #4dff4d; --powerup-b-color: #4da6ff; --powerup-c-color: #cc66ff; --powerup-s-color: #a9d4ff;
            --hud-color: #ffffff; --gauge-color: #00ffff; --gauge-bg-color: #33334d; --button-bg: rgba(255, 255, 255, 0.1); --button-border: rgba(255, 255, 255, 0.5); --shard-color: #a9d4ff;
            --rarity-rare: #00aaff; --rarity-legendary: #ff8000; --rarity-mythic: #ff40ff;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-color); color: var(--hud-color); font-family: 'Press Start 2P',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif; -webkit-tap-highlight-color: transparent; }
        #game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
        canvas { background-color: #000; border: 1px solid var(--button-border); touch-action: none; position: relative; z-index: 5; }
        .hud, .screen-overlay { text-shadow: 2px 2px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000; }
        .hud { position: absolute; width: 100%; padding: 15px 20px; font-size: 1em; line-height: 1.4; pointer-events: none; z-index: 15; }
        #top-hud { top: 0; display: flex; justify-content: space-between; align-items: flex-start; }
        #bottom-hud { bottom: 0; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #chrono-gauge-container { width: 80%; height: 15px; background-color: var(--gauge-bg-color); border: 2px solid var(--button-border); border-radius: 10px; overflow: hidden; }
        #chrono-gauge-bar { width: 0%; height: 100%; background-color: var(--gauge-color); transition: width 0.1s linear; }
        #bomb-info, #life-info { font-size: 1.2em; }
        .mobile-control { position: absolute; bottom: 30px; width: 70px; height: 70px; background-color: var(--button-bg); border: 2px solid var(--button-border); border-radius: 50%; color: white; display: none; justify-content: center; align-items: center; font-size: 0.8em; user-select: none; z-index: 10; }
        #chrono-break-button { left: 30px; }
        #bomb-button { right: 30px; }
        .mobile-control.active { background-color: rgba(0, 255, 255, 0.5); }
        .screen-overlay { position: absolute; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 20; cursor: default; padding: 10px; }
        .screen-overlay h1 { font-size: 2.5em; line-height: 1.2; margin-bottom: 10px; }
        .screen-overlay p { font-size: 1em; margin: 5px 0; line-height: 1.5; }
        .screen-overlay button { padding: 10px 20px; font-size: 1em; font-weight: bold; color: var(--bg-color); background-color: var(--player-color); border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 0 15px var(--player-color); transition: all 0.1s; margin-top: 10px; font-family: 'Press Start 2P', cursive; }
        .screen-overlay button:hover:not(:disabled) { transform: scale(1.05); filter: brightness(1.2); }
        .screen-overlay button:active { transform: scale(0.95); }
        .screen-overlay button:disabled { background-color: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        #main-menu-screen { background: radial-gradient(ellipse at center, rgba(13, 13, 26, 0.95) 0%, rgba(13, 13, 26, 1) 100%); gap: 10px; justify-content: flex-start; padding-top: 3%; }
        #main-menu-screen h1 { text-shadow: 3px 3px 0px var(--player-color), -3px -3px 0px var(--player-color), 3px -3px 0px var(--player-color), -3px 3px 0px var(--player-color); font-size: 2.2em; }
        #game-over-screen { display: none; }
        #game-over-screen h1 { text-shadow: 2px 2px 0px #ff0000, -2px -2px 0px #ff0000, 2px -2px 0px #ff0000, -2px 2px 0px #ff0000; }
        #shard-display { color: var(--shard-color); font-size: 1.2em; font-weight: bold; margin-bottom: 10px; background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px; border: 1px solid var(--button-border); }
        #shards-earned.animate { animation: pop-in 0.5s ease-out; }
        @keyframes pop-in { 0% { transform: scale(0.5); opacity: 0; } 80% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); } }
        #main-menu-content { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 550px; flex-grow: 1; gap: 10px; }
        #main-panel { display: flex; width: 100%; gap: 10px; flex-grow: 1; min-height: 0; }
        #character-list-panel { display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding-right: 5px; flex-basis: 45%; }
        .char-portrait { width: 100%; height: 80px; border: 3px solid var(--button-border); border-radius: 10px; cursor: pointer; display: flex; justify-content: flex-start; align-items: center; transition: all 0.2s; padding: 10px; background: rgba(0,0,0,0.2); position: relative; gap: 10px; }
        .char-portrait.selected { border-color: var(--player-color); background: rgba(0, 255, 255, 0.1); box-shadow: 0 0 10px var(--player-color); }
        .char-portrait.locked { background-color: rgba(0,0,0,0.7); cursor: pointer; }
        .char-portrait.locked::after { content: 'üîí'; position: absolute; top: 5px; right: 10px; font-size: 1.2em; }
        .char-portrait-info { display: flex; flex-direction: column; text-align: left; }
        .char-icon { font-size: 2em; }
        .char-name { font-weight: bold; font-size: 0.8em; }
        .char-highscore { font-size: 0.6em; color: var(--enemy-color-2); }
        #right-panel { flex-basis: 55%; display: flex; flex-direction: column; gap: 10px; background: rgba(0,0,0,0.2); border: 1px solid var(--button-border); border-radius: 10px; padding: 10px; }
        #selected-char-details { text-align: center; font-size: 0.7em; line-height: 1.3; border-bottom: 1px solid var(--button-border); padding-bottom: 8px; }
        #skin-selection-container { display: flex; justify-content: center; gap: 8px; }
        .skin-swatch { width: 25px; height: 25px; border: 2px solid var(--button-border); border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .skin-swatch.selected { transform: scale(1.2); box-shadow: 0 0 10px #fff; }
        .skin-swatch.locked { background: repeating-linear-gradient(45deg, #333, #333 4px, #444 4px, #444 8px); cursor: not-allowed; }
        .skin-swatch.rarity-rare { border-color: var(--rarity-rare); } .skin-swatch.rarity-legendary { border-color: var(--rarity-legendary); } .skin-swatch.rarity-mythic { border-color: var(--rarity-mythic); }
        #upgrade-section { display: flex; flex-direction: column; gap: 8px; font-size: 0.7em; }
        .upgrade-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .upgrade-row button { padding: 5px 8px; font-size: 0.9em; margin-top: 0; }
        #bottom-buttons { display: flex; flex-direction: column; gap: 10px; width: 100%; }
        .gacha-buttons { display: flex; justify-content: center; gap: 10px; }
        .gacha-buttons button { flex-grow: 1; font-size: 0.8em; }
        #start-game-button { padding: 12px 20px; font-size: 1.2em; width: 100%; }
        #control-toggle-button { font-size: 0.7em; padding: 8px 12px; margin-top: 0; background-color: #444; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="main-menu-screen" class="screen-overlay">
            <h1>CHRONO BREAK</h1>
            <div id="main-menu-content">
                <p id="shard-display">üíé 0</p>
                <div id="main-panel">
                    <div id="character-list-panel"></div>
                    <div id="right-panel">
                        <div id="selected-char-details"></div>
                        <div id="skin-selection-container"></div>
                        <div id="upgrade-section"></div>
                    </div>
                </div>
                <div id="bottom-buttons">
                    <div class="gacha-buttons">
                        <button id="char-gacha-button">Ï∫êÎ¶≠ÌÑ∞ ÎΩëÍ∏∞ (üíé1500)</button>
                        <button id="skin-gacha-button">Ïä§ÌÇ® ÎΩëÍ∏∞ (üíé10000)</button>
                    </div>
                    <button id="control-toggle-button">Ïª®Ìä∏Î°§: ÌÇ§Î≥¥Îìú</button>
                    <button id="start-game-button">START</button>
                </div>
            </div>
        </div>
        <div id="top-hud" class="hud">
            <div><span id="score">SCORE: 0</span><br><span id="high-score">HIGH: 0</span></div>
            <div style="text-align: right;"><span id="life-info"></span><br><span id="bomb-info"></span></div>
        </div>
        <div id="bottom-hud" class="hud">
            <div id="chrono-gauge-container"><div id="chrono-gauge-bar"></div></div>
        </div>
        <div id="chrono-break-button" class="mobile-control">BREAK</div>
        <div id="bomb-button" class="mobile-control">BOMB</div>
        <div id="game-over-screen" class="screen-overlay">
            <h1>GAME OVER</h1>
            <p id="final-score"></p>
            <p id="shards-earned"></p>
            <button id="return-to-menu-button">MENU</button>
        </div>
    </div>

    <script>
    // --- 1. Ï†ÑÏó≠ Î≥ÄÏàò Î∞è ÏÉÅÏàò Ï¥àÍ∏∞Ìôî ---
    const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
    const mainMenuScreen = document.getElementById('main-menu-screen'), gameOverScreen = document.getElementById('game-over-screen');
    const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('high-score'), lifeInfoEl = document.getElementById('life-info'), bombInfoEl = document.getElementById('bomb-info'), chronoGaugeBarEl = document.getElementById('chrono-gauge-bar');
    const shardDisplay = document.getElementById('shard-display'), charListPanel = document.getElementById('character-list-panel'), upgradeSection = document.getElementById('upgrade-section'), skinSelectionContainer = document.getElementById('skin-selection-container'), selectedCharDetailsEl = document.getElementById('selected-char-details');
    const charGachaButton = document.getElementById('char-gacha-button'), skinGachaButton = document.getElementById('skin-gacha-button'), startGameButton = document.getElementById('start-game-button'), returnToMenuButton = document.getElementById('return-to-menu-button'), controlToggleButton = document.getElementById('control-toggle-button');
    const finalScoreEl = document.getElementById('final-score'), shardsEarnedEl = document.getElementById('shards-earned');
    const mobileChronoButton = document.getElementById('chrono-break-button'), mobileBombButton = document.getElementById('bomb-button');
    let gameState = 'mainMenu', controlMode = 'keyboard', gameSpeed = 1, lastTime = 0, animationFrameId = null;
    let score = 0, highScore = 0, scoreMultiplier = 1, wave = 0, waveTimer = 0;
    let player, enemies = [], bullets = [], particles = [], powerUps = [], backgroundStars = [];
    let screenShake = 0, lowHealthPulse = 0;
    const colors = {};
    let chronoShards = 0, waveClearBonus = 0, bossKillBonus = 0;
    let selectedCharacterId = 'stinger';

    const SKIN_COLORS = {
        stinger: { normal: '#00ffff', rare: '#00ff88', legendary: '#7df9ff', mythic: '#ffd700', accent: '#f0f' }, guardian: { normal: '#4da6ff', rare: '#8a2be2', legendary: '#e0ffff', mythic: '#1e90ff', accent: '#ffd700' }, spectre: { normal: '#9d74e0', rare: '#ff69b4', legendary: '#f0f0f0', mythic: '#4b0082', accent: '#ff00ff' }, pulse: { normal: '#ffc800', rare: '#ff4500', legendary: '#ffff00', mythic: '#dc143c', accent: '#ff8c00' }, blade: { normal: '#f0f', rare: '#ff0000', legendary: '#ff4500', mythic: '#ffffff', accent: '#ff0000' }, nova: { normal: '#ff7f50', rare: '#ff1493', legendary: '#ffdead', mythic: '#f4a460', accent: '#ff4500' }, rift: { normal: '#20b2aa', rare: '#00ced1', legendary: '#afeeee', mythic: '#7fffd4', accent: '#ffffff' }, aegis: { normal: '#b0c4de', rare: '#778899', legendary: '#f8f8ff', mythic: '#e6e6fa', accent: '#00ffff' }, berserker: { normal: '#dc143c', rare: '#ff6347', legendary: '#ff0000', mythic: '#8b0000', accent: '#ffff00' }, tempest: { normal: '#4682b4', rare: '#87ceeb', legendary: '#add8e6', mythic: '#b0e0e6', accent: '#ffffff' },
        phase: { normal: '#f0e68c', rare: '#ffd700', legendary: '#fafad2', mythic: '#fffacd', accent: '#ffffff' }, echo: { normal: '#dda0dd', rare: '#da70d6', legendary: '#ee82ee', mythic: '#ff00ff', accent: '#ffffff' }, comet: { normal: '#add8e6', rare: '#87cefa', legendary: '#00bfff', mythic: '#1e90ff', accent: '#ffffff' },
    };
    const SKIN_RARITY = { normal: 0, rare: 1, legendary: 2, mythic: 3 };
    const SKIN_GEOMETRY = {
        default: [{x:0,y:-1},{x:-0.66,y:0.5},{x:0.66,y:0.5}],
        stinger: [{x:0,y:-1.2},{x:-0.3,y:0.4},{x:-0.8,y:0.2},{x:0.8,y:0.2},{x:0.3,y:0.4}], blade: [{x:0,y:-1.1},{x:-1,y:0.6},{x:0,y:0.3},{x:1,y:0.6}], guardian: [{x:0,y:-1},{x:-0.8,y:-0.2},{x:-0.8,y:0.6},{x:0.8,y:0.6},{x:0.8,y:-0.2}],
        echo: [{x:0,y:-1},{x:-0.9,y:0},{x:-0.5,y:0.8},{x:0.5,y:0.8},{x:0.9,y:0}], phase: [{x:-0.5,y:-1},{x:0.5,y:-1},{x:1,y:0},{x:0.5,y:1},{x:-0.5,y:1},{x:-1,y:0}], comet: [{x:0,y:-1.2},{x:-0.5,y:0.6},{x:0,y:0.2},{x:0.5,y:0.6}],
    };

    let characters = {
        stinger: { name: 'Ïä§ÌåÖÏñ¥', icon: '‚ñ∂', unlocked: true, desc: 'ÏßëÏ§ëÌòï ÌëúÏ§Ä ÏÉ∑' }, guardian: { name: 'Í∞ÄÎîîÏñ∏', icon: '‚ùñ', unlocked: false, desc: 'Í¥ëÏó≠ ÏÉ∑, Ìè≠ÌÉÑ+1' }, spectre: { name: 'Ïä§ÌéôÌÑ∞', icon: '‚¨ü', unlocked: false, desc: 'Ïú†ÎèÑÌÉÑ, Í≤åÏù¥ÏßÄ+' }, pulse: { name: 'ÌéÑÏä§', icon: '‚óé', unlocked: false, desc: 'Í∑ºÏ†ë ÌååÎèô, Ï≤òÏπò Ïãú Í≤åÏù¥ÏßÄ ÌöåÎ≥µ' }, blade: { name: 'Î∏îÎ†àÏù¥Îìú', icon: '‚ñ≤', unlocked: false, desc: 'Í¥ÄÌÜµ Í≥µÍ≤©, ÏÉùÎ™Ö 1, Ï†êÏàò 2Î∞∞' }, nova: { name: '‚úß', unlocked: false, desc: 'Ï∞®ÏßÄ Î†àÏù¥Ï†Ä Î∞úÏÇ¨' }, rift: { name: '‚ÜØ', unlocked: false, desc: 'Ìè≠ÌÉÑ ÎåÄÏã† Î∏îÎßÅÌÅ¨' }, aegis: { name: 'üõ°Ô∏è', unlocked: false, desc: 'Ï¥ùÏïå Ìù°Ïàò Î∞©Ïñ¥Îßâ' }, berserker: { name: 'üî•', unlocked: false, desc: 'Ï≤¥Î†• ÎÇÆÏùÑÏàòÎ°ù Í≥µÏÜç Ï¶ùÍ∞Ä' }, tempest: { name: 'üåÄ', unlocked: false, desc: 'Í≥µÏ†ÑÌïòÎäî Ïò§Î∏åÏ†ùÌä∏ Î∞úÏÇ¨' },
        phase: { name: 'ÌéòÏù¥Ï¶à', icon: '¬ª', unlocked: false, desc: 'ÏßßÏùÄ Î¨¥Ï†Å ÎåÄÏãú' }, echo: { name: 'ÏóêÏΩî', icon: '‚Ü∫', unlocked: false, desc: 'ÌÉÄÏù¥Î∞ç ÎßûÏ∂∞ Ìå®ÎßÅ/Î∞òÍ≤©' }, comet: { name: 'ÏΩîÎ©ß', icon: '‚òÑÔ∏è', unlocked: false, desc: 'Ï¥àÍ≥†ÏÜç Í∏∞Îèô, Ï≤¥Î†• -1' },
    };
    Object.keys(characters).forEach(id => {
        characters[id].highScore = 0; characters[id].selectedSkin = 'normal'; characters[id].skins = { normal: { unlocked: true }, rare: { unlocked: false }, legendary: { unlocked: false }, mythic: { unlocked: false } };
    });
    let upgrades = { power: { name: 'ÏãúÏûë ÌååÏõå', level: 0, maxLevel: 3, cost: [1000, 3000, 7000] }, bombs: { name: 'ÏãúÏûë Ìè≠ÌÉÑ', level: 0, maxLevel: 2, cost: [2000, 5000] }, gauge: { name: 'Í≤åÏù¥ÏßÄ Ìö®Ïú®', level: 0, maxLevel: 4, cost: [1500, 3500, 6000, 9000] }, magnet: { name: 'ÏïÑÏù¥ÌÖú ÏûêÏÑù', level: 0, maxLevel: 1, cost: [10000] } };

    // --- 2. ÏÇ¨Ïö¥Îìú ÏãúÏä§ÌÖú ---
    let audioContext; const audioBuffers = {};
    const soundAssets = { shoot: 'data:audio/wav;base64,UklGRlgAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAP//AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8=', explosion: 'data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSgAAAA+Pj8/Pz4+Pj4+Pj49PT09PTw8PDs7Ozo6Ojk5OTg4ODc3Njc2NjU1NTQ0NDMzMzIyMjExMTAwLy8uLSwrKikoJyYmJSUlJCQkIyIiISAgHx4eHBsaGRgXFhUUExITEREOBwgFBAIB', graze: 'data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAA//8BAAECBQQHCAkKCw0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0A=', playerHit: 'data:audio/wav;base64,UklGRmAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAABAAAD8AP4A/gD9APwA+wD5APgA9wD0APMA8gDxAPAA7wDsAOsA6ADnAOYA4wDiAOEA3wDcANsA2ADRANAAzwDMAssCyQLEAsECwQHCAb8BvgG9AbwBvQG+Ab8BwgHCAsECwQLFAsYCyQLLAMwA0ADSANkA3ADeAOAA4wDnAOoA7QDyAPUA+gD/AAQBCgEQARYBGgEcASQBKgEuATMBPAE/AUQBSgFOAVIBVwFYAVwBXgFiAWgBbAFwAW8BcgF3AXgBewF9AX8BfwF+AXwBcgFvAWwBagFkAWQBZAFhAVgBUwFPAUkBRQFBAT4BOgEwASoBJwEhARwBFgEOAQsBBgECAP4A+wD0AO0A5wDhANkA0AC/AbwBsgGnAZwBlgGRAZAAkAGSAZgBoQGwAbwBwwHNAeYB+gIIAhMCHQImAiwCMAI3Aj4CRQJMAloCXQJgAmYCcAJ2AoACjgKiAq4CwgLPAtgC4gLrAvUC+wL+AwIDBwMLAxcDGgMiAykDMANAA0sDWANgA2gDcAN8A4gDkQOcA6sDtQO/A8wD3APqA/0DAwQIBhEKDxQVGh0gIycoMDM5PEBHS1JcYW5xfISQlp+lrsbT3+n6/w==', itemGet: 'data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YRoAAAAaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc=', chronoStart: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAPz49Ozg1MzExLy0rKCcmJSQjIiAfHhsZFRMREQ4HCAUEAgE=', chronoEnd: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAAgQFBwgODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygp', laser: 'data:audio/wav;base64,UklGRlQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUwDAAB/f3+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1VWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==', blink: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAADg3uLa0s/LxcC4t7GuqaSgmpaTkZGNi4eCfnx3cWpnZWBgXVpYVFFOTEpIRkBERUJGQj89Ojg1NC8uKScnJSUlJCQjIiEgHx4cHBsaGRgXFhUUExITEREOBwgFBAIB', shieldUp: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAQUJDREVGR0hJSktMTU5PUFFSU1VWV1hZWltcXV5fYGFiY2RlZmdoaQ==', shieldDown: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAaGlmZWRjYmFfYV5dWltZWFhVVFNRS0dFRENCQUA/PTw6OQ==', parry: 'data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAA+vr5+Pb18/Lx7+/u7ezr6ufm5eHh39/e3dza2dvY19XU09LR0M/NzMvKyMfGxcLDv728ubq5t7S0s6+ur6yqp6SjoZ+dm5iWlZGOjYqHh4B+fXt4doA=' };
    async function initAudio() { if (audioContext) return; try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); for (const name of Object.keys(soundAssets)) { const response = await fetch(soundAssets[name]); const arrayBuffer = await response.arrayBuffer(); audioBuffers[name] = await audioContext.decodeAudioData(arrayBuffer); } } catch (e) { console.error("Web Audio API error", e); } }
    function playSound(name, volume = 0.7) { if (!audioContext || !audioBuffers[name] || audioContext.state === 'suspended') return; const source = audioContext.createBufferSource(); source.buffer = audioBuffers[name]; const gainNode = audioContext.createGain(); gainNode.gain.value = volume; source.connect(gainNode); gainNode.connect(audioContext.destination); source.start(0); }

    // --- 3. ÌÅ¥ÎûòÏä§ Ï†ïÏùò ---
    class Player {
        constructor() {
            this.x = canvas.width / 2; this.y = canvas.height - 80; this.size = 12; this.hitboxSize = 4; this.grazeRadius = 40; this.speed = 280;
            this.shootCooldown = 0; this.isInvincible = false; this.invincibleTimer = 0; this.chronoGauge = 0; this.chronoGaugeMax = 100;
            this.power = 1 + upgrades.power.level;
            let baseLives = 3; if (selectedCharacterId === 'blade' || selectedCharacterId === 'comet') baseLives = 2; this.lives = baseLives;
            const charData = characters[selectedCharacterId]; this.skin = charData.selectedSkin; this.skinRarity = SKIN_RARITY[this.skin]; this.color = SKIN_COLORS[selectedCharacterId][this.skin]; this.accentColor = SKIN_COLORS[selectedCharacterId]['accent'];
            const specialBombChars = ['rift', 'aegis', 'phase', 'echo']; const initialBombs = (specialBombChars.includes(selectedCharacterId)) ? 0 : 3 + upgrades.bombs.level + (selectedCharacterId === 'guardian' ? 1 : 0);
            this.bombs = Math.min(5, initialBombs);
            // ÌäπÏàò Îä•Î†• Ï¥àÍ∏∞Ìôî
            if (selectedCharacterId === 'comet') this.speed *= 1.5;
            this.chargeLevel = 0; this.chargeMax = 1.5; // Nova
            this.blinkCooldown = 0; this.blinkMaxCooldown = 5; // Rift
            this.dashCooldown = 0; this.dashMaxCooldown = 1.5; // Phase
            this.isParrying = false; this.parryTimer = 0; this.parryPower = 0; // Echo
            this.orbiters = []; this.orbiterCooldown = 0; // Tempest
            this.isShielding = false; this.shieldTimer = 0; this.shieldPower = 0; // Aegis
        }
        update(deltaTime, input) {
            if (this.skinRarity === 3) { particles.push(new Particle(this.x, this.y, this.color, 3, { lifespan: 0.5, fade: true, type: 'trail' })); }
            let moveX = 0, moveY = 0; if (input.keys.ArrowLeft || input.keys.a) moveX -= 1; if (input.keys.ArrowRight || input.keys.d) moveX += 1; if (input.keys.ArrowUp || input.keys.w) moveY -= 1; if (input.keys.ArrowDown || input.keys.s) moveY += 1;
            if (controlMode === 'touch' && input.touch.active) { const dx = input.touch.x - this.x, dy = input.touch.y - this.y, dist = Math.hypot(dx, dy); if (dist > 1) { moveX = dx / dist; moveY = dy / dist; } }
            const isMoving = moveX !== 0 || moveY !== 0 || (controlMode === 'touch' && input.touch.active);
            if (!this.isShielding) {
                const effectiveSpeed = this.speed * deltaTime * (gameSpeed < 1 ? 1.5 : 1); this.x += moveX * effectiveSpeed; this.y += moveY * effectiveSpeed;
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            }
            this.shootCooldown -= deltaTime;
            if (selectedCharacterId === 'nova') { if (!isMoving && this.shootCooldown <= 0) { this.chargeLevel = Math.min(this.chargeMax, this.chargeLevel + deltaTime); } else { if (this.chargeLevel >= this.chargeMax) { this.shoot(); } this.chargeLevel = 0; } }
            if (this.shootCooldown <= 0 && !this.isShielding) { this.shoot(); }
            if (this.isInvincible) { this.invincibleTimer -= deltaTime; if (this.invincibleTimer <= 0) this.isInvincible = false; }
            const gaugeConsumption = 25 * (1 - (upgrades.gauge.level * 0.1));
            if ((input.keys.Shift || input.touch.chronoActive) && this.chronoGauge > 0) { if(gameSpeed === 1) playSound('chronoStart'); gameSpeed = 0.25; this.chronoGauge -= gaugeConsumption * deltaTime; if (this.chronoGauge < 0) this.chronoGauge = 0; } else { if(gameSpeed < 1) playSound('chronoEnd'); gameSpeed = 1; }
            
            // ÌäπÏàò Îä•Î†• ÏóÖÎç∞Ïù¥Ìä∏
            const bombPressed = input.keys.x || input.touch.bombPressed;
            if(bombPressed) { input.keys.x = false; input.touch.bombPressed = false; }
            if (selectedCharacterId === 'rift') { this.blinkCooldown = Math.max(0, this.blinkCooldown - deltaTime); if (bombPressed && this.blinkCooldown <= 0) this.useBlink(isMoving ? {x: moveX, y: moveY} : null); }
            else if (selectedCharacterId === 'phase') { this.dashCooldown = Math.max(0, this.dashCooldown - deltaTime); if (bombPressed && this.dashCooldown <= 0) this.useDash(moveX, moveY); }
            else if (selectedCharacterId === 'echo') { this.parryTimer = Math.max(0, this.parryTimer - deltaTime); if(this.isParrying && this.parryTimer <= 0) this.releaseParry(); if (bombPressed && !this.isParrying) this.activateParry(); }
            else if (selectedCharacterId === 'aegis') { if (bombPressed) this.toggleAegisShield(); if (this.isShielding) { this.shieldTimer -= deltaTime; if (this.shieldTimer <= 0) this.toggleAegisShield(); } }
            else if (selectedCharacterId === 'tempest') { this.orbiters.forEach((orb, i) => orb.update(deltaTime, this, i, this.orbiters.length)); if (this.orbiters.length < this.power) { this.orbiterCooldown -= deltaTime; if (this.orbiterCooldown <= 0) { this.orbiters.push(new Bullet(this.x, this.y, 0, 0, 'player', {isOrbiter: true, skinRarity: this.skinRarity, color:this.color, accentColor:this.accentColor})); this.orbiterCooldown = 2.0; } } }
            else if (bombPressed && this.bombs > 0) { this.useBomb(); }
        }
        draw(ctx) {
            if (this.isInvincible && Math.floor(this.invincibleTimer * 10) % 2 === 0) return;
            ctx.shadowColor = this.color; ctx.shadowBlur = this.skinRarity > 0 ? 10 + this.skinRarity * 5 : 5;
            if (this.skinRarity === 3) { const auraSize = this.size * (1.5 + Math.sin(Date.now() / 200) * 0.2); const gradient = ctx.createRadialGradient(this.x, this.y, this.size * 0.5, this.x, this.y, auraSize); gradient.addColorStop(0, this.accentColor + '80'); gradient.addColorStop(1, this.accentColor + '00'); ctx.fillStyle = gradient; ctx.fillRect(this.x - auraSize, this.y - auraSize, auraSize * 2, auraSize * 2); }
            const geometry = (this.skinRarity >= 2 && SKIN_GEOMETRY[selectedCharacterId]) ? SKIN_GEOMETRY[selectedCharacterId] : SKIN_GEOMETRY.default;
            ctx.fillStyle = this.color; ctx.beginPath();
            geometry.forEach((p, i) => { const xPos = this.x + p.x * this.size; const yPos = this.y + p.y * this.size; if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos); });
            ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0;
            if (selectedCharacterId === 'nova' && this.chargeLevel > 0) { ctx.strokeStyle = this.color; ctx.lineWidth = 1 + (this.chargeLevel / this.chargeMax) * 3; ctx.globalAlpha = this.chargeLevel / this.chargeMax; ctx.beginPath(); ctx.arc(this.x, this.y, this.size + this.chargeLevel * 5, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1; }
            if (this.isShielding) { ctx.fillStyle = this.color + '40'; ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, 30, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
            if (this.isParrying) { ctx.fillStyle = this.accentColor; ctx.globalAlpha = 0.5 + Math.sin(this.parryTimer * 50) * 0.5; ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
        }
        shoot() {
            let p = Math.min(this.power, 5); let bulletOptions = { skinRarity: this.skinRarity, color: this.color, accentColor: this.accentColor };
            this.shootCooldown = 0.12;
            if (selectedCharacterId === 'berserker') { this.shootCooldown *= (0.4 + 0.6 * (this.lives / 3)); }
            else if (selectedCharacterId === 'spectre') { this.shootCooldown = 0.25; }
            playSound('shoot', 0.3);
            switch (selectedCharacterId) {
                case 'tempest': return;
                case 'nova': if (this.chargeLevel >= this.chargeMax) { playSound('laser', 0.8); bullets.push(new Bullet(this.x, this.y - 30, -90, 2000, 'player', { ...bulletOptions, isPiercing: true, isLaser: true, width: 15 + p * 2, height: canvas.height, lifespan: 0.3 })); this.chargeLevel = 0; this.shootCooldown = 0.5; } else { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', bulletOptions)); } break;
                case 'blade': bullets.push(new Bullet(this.x, this.y, -90, 1200, 'player', { ...bulletOptions, isPiercing: true, width: 4 + p, height: 40 })); break;
                case 'pulse': bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { ...bulletOptions, isWave: true, size: 15 + p * 5, lifespan: 0.2 })); break;
                case 'spectre': bullets.push(new Bullet(this.x, this.y, -90, 400, 'player', { ...bulletOptions, isHoming: true })); if (p >= 3) bullets.push(new Bullet(this.x - 15, this.y, -90, 400, 'player', { ...bulletOptions, isHoming: true })); if (p >= 5) bullets.push(new Bullet(this.x + 15, this.y, -90, 400, 'player', { ...bulletOptions, isHoming: true })); break;
                case 'guardian': bullets.push(new Bullet(this.x, this.y, -90, 700, 'player', bulletOptions)); for(let i=1; i<=Math.floor(p/2); i++) { bullets.push(new Bullet(this.x, this.y, -90 - i * 15, 700, 'player', bulletOptions)); bullets.push(new Bullet(this.x, this.y, -90 + i * 15, 700, 'player', bulletOptions)); } break;
                default: if (p === 1) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', bulletOptions)); } else if (p === 2) { bullets.push(new Bullet(this.x - 5, this.y, -90, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x + 5, this.y, -90, 800, 'player', bulletOptions)); } else if (p === 3) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x, this.y, -85, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x, this.y, -95, 800, 'player', bulletOptions)); } else if (p === 4) { bullets.push(new Bullet(this.x - 8, this.y, -90, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x + 8, this.y, -90, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x - 4, this.y, -85, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x + 4, this.y, -95, 800, 'player', bulletOptions)); } else if (p >= 5) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x, this.y, -80, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x, this.y, -100, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x - 10, this.y, -90, 800, 'player', bulletOptions)); bullets.push(new Bullet(this.x + 10, this.y, -90, 800, 'player', bulletOptions)); } break;
            }
        }
        takeHit() { if (this.isInvincible) return; if (this.isParrying) { this.parryPower++; return; } if (this.isShielding) return; playSound('playerHit'); screenShake = 15; this.lives--; this.power = Math.max(1, this.power - 1); if (selectedCharacterId === 'tempest') this.orbiters.pop(); this.isInvincible = true; this.invincibleTimer = 2; createExplosion(this.x, this.y, this.color, 40); if (this.lives < 0) { gameOver(); } }
        addChronoGauge(amount) { const multiplier = selectedCharacterId === 'spectre' ? 1.5 : 1; const lateGamePenalty = Math.max(0.3, 1 - (wave * 0.05)); this.chronoGauge = Math.min(this.chronoGaugeMax, this.chronoGauge + amount * multiplier * lateGamePenalty); if (this.skinRarity === 3) { for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, this.accentColor, 3, { type: 'spark' })); } }
        useBomb() { if (this.bombs <= 0) return; this.bombs--; playSound('explosion', 1.0); this.isInvincible = true; this.invincibleTimer = 1.5; bullets = bullets.filter(b => b.owner !== 'enemy'); enemies.forEach(e => e.takeDamage(50)); createScreenFlash(); }
        useBlink(direction) { playSound('blink'); this.blinkCooldown = this.blinkMaxCooldown; this.isInvincible = true; this.invincibleTimer = 0.3; const blinkDist = 100; createExplosion(this.x, this.y, this.color, 20, { type: 'warp' }); if(direction) { this.x += direction.x * blinkDist; this.y += direction.y * blinkDist; } else { this.y -= blinkDist; } this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y)); createExplosion(this.x, this.y, this.color, 20, { type: 'warp' }); }
        useDash(moveX, moveY) { playSound('blink', 0.5); this.dashCooldown = this.dashMaxCooldown; this.isInvincible = true; this.invincibleTimer = 0.2; const dashDist = 60; createExplosion(this.x, this.y, this.color, 15, { type: 'warp', speed: 300 }); let dirX = moveX, dirY = moveY; if (dirX === 0 && dirY === 0) dirY = -1; const mag = Math.hypot(dirX, dirY); this.x += (dirX/mag) * dashDist; this.y += (dirY/mag) * dashDist; }
        activateParry() { this.isParrying = true; this.parryTimer = 0.25; this.parryPower = 0; }
        releaseParry() { this.isParrying = false; if (this.parryPower > 0) { playSound('parry'); for(let i=0; i<this.parryPower; i++) { const angle = -90 + (Math.random() - 0.5) * 60; bullets.push(new Bullet(this.x, this.y, angle, 900, 'player', { size: 8, isPiercing: true, width: 8, height: 20, skinRarity: this.skinRarity, color: this.accentColor, accentColor: this.color })); } } }
        toggleAegisShield() { this.isShielding = !this.isShielding; if (this.isShielding) { playSound('shieldUp'); this.shieldTimer = 2.0; this.shieldPower = 0; } else { playSound('shieldDown'); if (this.shieldPower > 0) { bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { isWave: true, size: 20 + this.shieldPower * 2, lifespan: 0.5, skinRarity: this.skinRarity, color: this.color, accentColor: this.accentColor })); } } }
    }

    class Bullet {
        constructor(x, y, angle, speed, owner, special = {}) {
            this.x = x; this.y = y; this.owner = owner; this.special = special;
            this.color = (owner === 'player' && special.color) ? special.color : colors.enemyBullet;
            if (special.isWave) { this.size = special.size; this.lifespan = special.lifespan; } else if (special.isPiercing) { this.width = special.width; this.height = special.height; this.hitEnemies = new Set(); } else if (special.isOrbiter) { this.size = 8; this.angle = 0; } else { this.size = special.size || 5; }
            const rad = angle * Math.PI / 180; this.vx = Math.cos(rad) * speed; this.vy = Math.sin(rad) * speed; this.grazed = false;
        }
        update(deltaTime, playerRef, index, totalOrbiters) {
            if (this.special.isOrbiter) { const baseAngle = (Date.now() / 1000) * 1.5; const offsetAngle = (Math.PI * 2 / totalOrbiters) * index; this.x = playerRef.x + Math.cos(baseAngle + offsetAngle) * 60; this.y = playerRef.y + Math.sin(baseAngle + offsetAngle) * 60; return; }
            if (this.special.isHoming && this.owner === 'player') { let closestEnemy = null, minDist = Infinity; for (const enemy of enemies) { const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < minDist) { minDist = dist; closestEnemy = enemy; } } if (closestEnemy) { const angleToTarget = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x); this.vx += Math.cos(angleToTarget) * 2000 * deltaTime; this.vy += Math.sin(angleToTarget) * 2000 * deltaTime; const speed = Math.hypot(this.vx, this.vy), maxSpeed = 400; if (speed > maxSpeed) { this.vx = (this.vx / speed) * maxSpeed; this.vy = (this.vy / speed) * maxSpeed; } } }
            if (this.special.lifespan) { this.lifespan -= deltaTime; }
            this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed;
            if (this.special.bouncesLeft > 0) { if (this.x < 0 || this.x > canvas.width) { this.vx *= -1; this.special.bouncesLeft--; } if (this.y < 0) { this.vy *= -1; this.special.bouncesLeft--; } }
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            if (this.owner === 'player' && this.special.skinRarity > 0) { ctx.shadowColor = this.color; ctx.shadowBlur = this.special.skinRarity * 5; if (this.special.skinRarity > 1) { particles.push(new Particle(this.x, this.y, this.special.accentColor, this.size * 0.7, { lifespan: 0.3, fade: true })); } }
            ctx.beginPath();
            if (this.special.isLaser) { ctx.globalAlpha = this.lifespan / 0.3; ctx.fillStyle = this.special.accentColor; ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); ctx.fillStyle = this.color; ctx.fillRect(this.x - this.width/4, this.y - this.height/2, this.width/2, this.height); ctx.globalAlpha = 1.0; }
            else if (this.special.isWave) { ctx.globalAlpha = this.lifespan / this.special.lifespan; ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.globalAlpha = 1; }
            else if (this.special.isPiercing) { ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); }
            else { ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); }
            ctx.fill(); ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; const difficulty = 1 + wave * 0.22; this.init(difficulty); this.isElite = false; if (wave > 10 && Math.random() < 0.1) this.makeElite(difficulty); }
        init(difficulty) { this.shootTimer = Math.random() * 2 + 1; this.bulletSpeed = 250 * (1 + wave * 0.1); switch(this.type) { case 'bulwark': this.size = 25; this.health = 80 * difficulty; this.color = colors.bulwark; this.speed = 30; this.scoreValue = 500; break; case 'sentinel': this.size = 18; this.health = 20 * difficulty; this.color = colors.sentinel; this.speed = 20; this.scoreValue = 400; this.laserCharge = 0; this.laserMaxCharge = 3; break; case 'barrier': this.size = 20; this.health = 30 * difficulty; this.color = colors.barrier; this.speed = 50; this.scoreValue = 350; this.shieldHealth = 50 * difficulty; break; case 'dasher': this.size = 12; this.health = 10 * difficulty; this.color = colors.dasher; this.speed = 300; this.scoreValue = 150; this.vy = this.speed; this.vx = Math.random() > 0.5 ? 100 : -100; break; case 'weaver': this.size = 18; this.health = 25 * difficulty; this.color = colors.weaver; this.speed = 80; this.scoreValue = 250; this.baseX = this.x; this.angle = 0; break; case 'kamikaze': this.size = 15; this.health = 5 * difficulty; this.color = colors.kamikaze; this.speed = 150; this.scoreValue = 200; break; case 'basic': this.size = 15; this.health = 15 * difficulty; this.color = colors.enemy1; this.speed = 100; this.scoreValue = 100; break; case 'shooter': this.size = 20; this.health = 40 * difficulty; this.color = colors.enemy2; this.speed = 60; this.scoreValue = 300; break; case 'boss': this.size = 50; this.health = (2000 + wave * 600) * difficulty; this.maxHealth = this.health; this.color = colors.boss; this.speed = 50; this.scoreValue = 10000; this.pattern = 'entry'; this.patternTimer = 0; this.patternDuration = 8; this.bulletSpeed *= 1.2; break; } }
        makeElite(difficulty) { this.isElite = true; this.health *= 2; this.bulletSpeed *= 1.2; this.color = '#FFD700'; this.scoreValue *= 3; if (this.shieldHealth) this.shieldHealth *= 2; }
        update(deltaTime) {
            switch(this.type) {
                case 'sentinel': if (this.y < 80) this.y += this.speed * deltaTime; this.laserCharge += deltaTime * gameSpeed; if (this.laserCharge >= this.laserMaxCharge) { this.shoot(); this.laserCharge = 0; } break;
                case 'dasher': this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed; if (this.x < 0 || this.x > canvas.width) this.vx *= -1; break;
                case 'weaver': this.y += this.speed * deltaTime * gameSpeed; this.angle += 3 * deltaTime * gameSpeed; this.x = this.baseX + Math.sin(this.angle) * 80; break;
                case 'kamikaze': if (player) { const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angleToPlayer) * this.speed * deltaTime * gameSpeed; this.y += Math.sin(angleToPlayer) * this.speed * deltaTime * gameSpeed; if (Math.hypot(this.x - player.x, this.y - player.y) < this.size + player.hitboxSize) { this.health = 0; player.takeHit(); } } break;
                default: this.y += this.speed * deltaTime * gameSpeed; break;
            }
            this.shootTimer -= deltaTime * gameSpeed; if (this.shootTimer <= 0 && this.type !== 'sentinel' && this.type !== 'boss') this.shoot();
            if (this.type === 'boss') {
                if (this.y < 150) { this.y += this.speed * deltaTime; } else { this.y = 150; }
                this.patternTimer += deltaTime; this.shootTimer -= deltaTime;
                if(this.shootTimer <= 0) this.shoot();
                if (this.patternTimer >= this.patternDuration) {
                    this.patternTimer = 0;
                    const patterns = ['crossfire', 'weave', 'sunburst', 'ricochet', 'desperate'];
                    const healthRatio = this.health / this.maxHealth;
                    if (healthRatio < 0.2) this.pattern = 'desperate';
                    else if (healthRatio < 0.4) this.pattern = 'ricochet';
                    else if (healthRatio < 0.6) this.pattern = 'sunburst';
                    else if (healthRatio < 0.8) this.pattern = 'weave';
                    else this.pattern = 'crossfire';
                }
            }
            if (this.y > canvas.height + this.size) this.health = 0;
        }
        draw(ctx) {
            ctx.fillStyle = this.color; ctx.beginPath();
            if (this.type === 'basic' || this.type === 'bulwark') { ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2); }
            else if (this.type === 'sentinel') { ctx.moveTo(this.x, this.y - this.size); ctx.lineTo(this.x - this.size, this.y + this.size); ctx.lineTo(this.x + this.size, this.y + this.size); }
            else { const sides = this.type === 'shooter' ? 6 : this.type === 'boss' ? 8 : 5; for (let i = 0; i < sides; i++) { const angle = (i / sides) * Math.PI * 2, xPos = this.x + this.size * Math.cos(angle), yPos = this.y + this.size * Math.sin(angle); if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos); } }
            ctx.closePath(); ctx.fill();
            if (this.isElite) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); }
            if (this.type === 'barrier' && this.shieldHealth > 0) { ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(this.x - this.size, this.y + this.size); ctx.lineTo(this.x + this.size, this.y + this.size); ctx.stroke(); }
            if(this.type === 'boss') { const barWidth = canvas.width * 0.8, barX = (canvas.width - barWidth) / 2; ctx.fillStyle = 'rgba(50,50,50,0.8)'; ctx.fillRect(barX, 10, barWidth, 10); ctx.fillStyle = this.color; ctx.fillRect(barX, 10, barWidth * (this.health / this.maxHealth), 10); }
            if (this.type === 'sentinel' && this.laserCharge > this.laserMaxCharge - 1) { ctx.strokeStyle = 'red'; ctx.globalAlpha = 0.5; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(player.x, player.y); ctx.stroke(); ctx.globalAlpha = 1.0; }
        }
        shoot() {
            if (!player) return; const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x) * 180 / Math.PI;
            switch(this.type) {
                case 'bulwark': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed * 0.5, 'enemy', {size: 15})); this.shootTimer = 4.0; break;
                case 'sentinel': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed * 4, 'enemy', {isPiercing: true, width: 4, height: 20})); break;
                case 'dasher': case 'barrier': break;
                case 'weaver': bullets.push(new Bullet(this.x, this.y, this.angle * 180 / Math.PI, this.bulletSpeed, 'enemy')); this.shootTimer = 1.5; break;
                case 'basic': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed, 'enemy')); this.shootTimer = 2.5; break;
                case 'shooter': for (let i = -1; i <= 1; i++) { bullets.push(new Bullet(this.x, this.y, angleToPlayer + i * 15, this.bulletSpeed * 0.8, 'enemy')); } this.shootTimer = 2.0; break;
                case 'boss':
                    const pTimer = this.patternTimer;
                    switch(this.pattern) {
                        case 'crossfire': for(let i=0; i<2; i++) bullets.push(new Bullet(this.x, this.y, angleToPlayer + i * 20 - 10, this.bulletSpeed * 1.1, 'enemy')); this.shootTimer = 0.3; break;
                        case 'weave': for (let i = 0; i < 5; i++) bullets.push(new Bullet(canvas.width * (pTimer/this.patternDuration) + i*20 - 40, -20, 90, this.bulletSpeed * 0.5, 'enemy')); this.shootTimer = 0.1; break;
                        case 'sunburst': for (let i = 0; i < 36; i++) bullets.push(new Bullet(this.x, this.y, i * 10, this.bulletSpeed, 'enemy')); this.shootTimer = 1.5; break;
                        case 'ricochet': bullets.push(new Bullet(this.x, this.y, pTimer * 40, this.bulletSpeed, 'enemy', {bouncesLeft: 1})); this.shootTimer = 0.2; break;
                        case 'desperate': bullets.push(new Bullet(this.x, this.y, angleToPlayer + Math.random()*40-20, this.bulletSpeed * 1.5, 'enemy')); if(Math.random() < 0.1) bullets.push(new Bullet(this.x, this.y, Math.random()*360, this.bulletSpeed * 0.8, 'enemy')); this.shootTimer = 0.1; break;
                        default: bullets.push(new Bullet(this.x, this.y, pTimer * 50, this.bulletSpeed * 0.9, 'enemy')); bullets.push(new Bullet(this.x, this.y, -pTimer * 50, this.bulletSpeed * 0.9, 'enemy')); this.shootTimer = 0.1; break;
                    } break;
            }
        }
        takeDamage(damage, fromBehind = false) {
            if (this.type === 'barrier' && this.shieldHealth > 0 && !fromBehind) { this.shieldHealth -= damage; if(this.shieldHealth <= 0) createExplosion(this.x, this.y + this.size, '#00ffff', 20); return; }
            this.health -= damage;
            if (this.health <= 0) {
                const scoreBonus = selectedCharacterId === 'blade' ? 2 : 1; score += this.scoreValue * Math.floor(scoreMultiplier) * scoreBonus;
                if (selectedCharacterId === 'pulse' && player) player.addChronoGauge(1);
                if (this.type === 'boss') bossKillBonus += 250;
                if (player && player.skinRarity >= 2) { createExplosion(this.x, this.y, player.accentColor, 35, { type: 'nova', secondaryColor: player.color }); }
                else { createExplosion(this.x, this.y, this.color, 20); }
                playSound('explosion');
                const dropChance = this.type === 'boss' ? 1.0 : 0.08;
                if (Math.random() < dropChance) { let itemType = 'P'; const rand = Math.random(); if (rand < 0.25) itemType = 'B'; else if (rand < 0.5) itemType = 'C'; powerUps.push(new PowerUpItem(this.x, this.y, itemType)); }
                else if (Math.random() < 0.015) { powerUps.push(new PowerUpItem(this.x, this.y, 'S')); }
            }
        }
    }
    class Particle {
        constructor(x, y, color, size, options = {}) { this.x = x; this.y = y; this.color = color; this.size = Math.random() * size + 2; this.lifespan = options.lifespan || 1; this.initialLifespan = this.lifespan; this.options = options; this.vx = (Math.random() - 0.5) * (options.speed || 150); this.vy = (Math.random() - 0.5) * (options.speed || 150); if (options.type === 'spark') { const angle = Math.random() * Math.PI * 2; this.vx = Math.cos(angle) * 300; this.vy = Math.sin(angle) * 300; } if (options.type === 'trail') { this.vx = 0; this.vy = 0; } }
        update(deltaTime) { this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed; this.lifespan -= deltaTime; if(this.options.type === 'spark' || this.options.type === 'nova') { this.vx *= 0.9; this.vy *= 0.9; } }
        draw(ctx) { ctx.globalAlpha = this.options.fade ? this.lifespan / this.initialLifespan : this.lifespan > 0.5 ? 1 : this.lifespan * 2; ctx.fillStyle = (this.options.type === 'nova' && Math.random() < 0.5) ? this.options.secondaryColor : this.color; ctx.beginPath(); if (this.options.type === 'warp') { ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size); } else { ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); } ctx.fill(); ctx.globalAlpha = 1; }
    }
    class PowerUpItem {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.size = 12; this.speed = 80; this.angle = 0; switch(type) { case 'P': this.color = colors.powerupP; break; case 'B': this.color = colors.powerupB; break; case 'C': this.color = colors.powerupC; break; case 'S': this.color = colors.powerupS; break; } }
        update(deltaTime) { this.angle += deltaTime * 5; if (upgrades.magnet.level > 0 && player) { const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angleToPlayer) * 300 * deltaTime; this.y += Math.sin(angleToPlayer) * 300 * deltaTime; } else { this.y += this.speed * deltaTime * gameSpeed; } }
        draw(ctx) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10; ctx.beginPath(); ctx.rect(-this.size, -this.size, this.size*2, this.size*2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 12px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const symbol = this.type === 'S' ? 'üíé' : this.type; ctx.fillText(symbol, 0, 1); ctx.restore(); }
    }

    // --- 4. ÌïµÏã¨ Î°úÏßÅ Î∞è Í≤åÏûÑ Î£®ÌîÑ ---
    const inputHandler = { keys: {}, touch: { x: 0, y: 0, active: false, chronoActive: false, bombPressed: false }, setup() { document.querySelectorAll('.mobile-control').forEach(el => el.style.display = 'none'); if (controlMode === 'touch') { document.querySelectorAll('.mobile-control').forEach(el => el.style.display = 'flex'); canvas.addEventListener('touchstart', this.handleTouch.bind(this)); canvas.addEventListener('touchmove', this.handleTouch.bind(this)); canvas.addEventListener('touchend', e => { this.touch.active = false; }); mobileChronoButton.addEventListener('touchstart', e => { e.preventDefault(); this.touch.chronoActive = true; mobileChronoButton.classList.add('active'); }); mobileChronoButton.addEventListener('touchend', e => { e.preventDefault(); this.touch.chronoActive = false; mobileChronoButton.classList.remove('active'); }); mobileBombButton.addEventListener('touchstart', e => { e.preventDefault(); this.touch.bombPressed = true; mobileBombButton.classList.add('active'); }); mobileBombButton.addEventListener('touchend', e => { e.preventDefault(); mobileBombButton.classList.remove('active'); }); } else { document.addEventListener('keydown', e => { this.keys[e.key] = true; }); document.addEventListener('keyup', e => { this.keys[e.key] = false; }); } }, handleTouch(e) { e.preventDefault(); this.touch.active = true; const rect = canvas.getBoundingClientRect(); this.touch.x = e.touches[0].clientX - rect.left; this.touch.y = e.touches[0].clientY - rect.top; } };
    function checkCollisions() {
        for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (!b || b.owner !== 'player') continue; const damage = b.special.isOrbiter ? (5 + player.power) * 0.2 : 10 + player.power; for (let j = enemies.length - 1; j >= 0; j--) { const e = enemies[j]; if (!e) continue; const dist = Math.hypot(b.x - e.x, b.y - e.y); if (dist < e.size + (b.special.isWave ? b.size : (b.size || 5))) { if (b.special.isPiercing) { if (b.hitEnemies.has(e)) continue; b.hitEnemies.add(e); } e.takeDamage(damage, b.y < e.y); if (!b.special.isPiercing && !b.special.isWave && !b.special.isOrbiter) { bullets.splice(i, 1); break; } } } }
        if (player && !player.isInvincible) { for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (!b || b.owner !== 'enemy') continue; if (player.isShielding) { const shieldDist = Math.hypot(b.x - player.x, b.y - player.y); if (shieldDist < 30 + b.size) { player.shieldPower++; createExplosion(b.x, b.y, player.color, 3); bullets.splice(i, 1); continue; } } if (!b.grazed) { const grazeDist = Math.hypot(b.x - player.x, b.y - player.y); if (grazeDist < player.grazeRadius + b.size) { b.grazed = true; scoreMultiplier += 0.1; player.addChronoGauge(3); playSound('graze'); } } const hitDist = Math.hypot(b.x - player.x, b.y - player.y); if (hitDist < player.hitboxSize + b.size) { player.takeHit(); bullets.splice(i, 1); scoreMultiplier = 1; break; } } }
        for (let i = powerUps.length - 1; i >= 0; i--) { const p = powerUps[i]; if (player) { const dist = Math.hypot(p.x - player.x, p.y - player.y); if (dist < player.size + p.size + (upgrades.magnet.level > 0 ? 50 : 0)) { playSound('itemGet', 1.0); createExplosion(p.x, p.y, p.color, 10); switch(p.type) { case 'P': player.power++; break; case 'B': player.bombs = Math.min(5, player.bombs + 1); break; case 'C': player.addChronoGauge(50); break; case 'S': chronoShards += 50 + Math.floor(Math.random() * 51); updateMainMenu(); break; } powerUps.splice(i, 1); } } }
    }
    function spawnEnemies(deltaTime) { waveTimer += deltaTime; const waveDuration = 45; if (waveTimer > waveDuration) { wave++; waveTimer = 0; waveClearBonus += 10; if (wave > 0 && wave % 3 === 0 && !enemies.some(e => e.type === 'boss')) { enemies.push(new Enemy(canvas.width / 2, -50, 'boss')); return; } } if (!enemies.some(e => e.type === 'boss')) { const spawnRate = 0.03 * (1 + wave * 0.20) * gameSpeed; if (Math.random() < spawnRate) { const x = Math.random() * canvas.width; const rand = Math.random(); let type = 'basic'; if (wave >= 8 && rand < 0.1) type = 'sentinel'; else if (wave >= 6 && rand < 0.2) type = 'bulwark'; else if (wave >= 4 && rand < 0.3) type = 'barrier'; else if (wave > 3 && rand < 0.45) type = 'kamikaze'; else if (wave > 2 && rand < 0.6) type = 'weaver'; else if (wave > 1 && rand < 0.75) type = 'dasher'; else if (rand < 0.9) type = 'shooter'; enemies.push(new Enemy(x, -20, type)); } } }
    function createExplosion(x, y, color, count, options) { for (let i = 0; i < count; i++) { particles.push(new Particle(x, y, color, 5, options)); } }
    let screenFlashTimer = 0; function createScreenFlash() { screenFlashTimer = 0.2; }
    function update(deltaTime) { if (gameState !== 'playing' || !player) return; lowHealthPulse += deltaTime * 5; if (screenShake > 0) screenShake = Math.max(0, screenShake - 30 * deltaTime); if (screenFlashTimer > 0) screenFlashTimer -= deltaTime; player.update(deltaTime, inputHandler); enemies.forEach(e => e.update(deltaTime)); bullets.forEach(b => b.update(deltaTime)); if (player && player.orbiters) player.orbiters.forEach((orb, i) => orb.update(deltaTime, player, i, player.orbiters.length)); particles.forEach(p => p.update(deltaTime)); powerUps.forEach(p => p.update(deltaTime)); checkCollisions(); spawnEnemies(deltaTime); bullets = bullets.filter(b => b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50 && (!b.special.lifespan || b.special.lifespan > 0)); enemies = enemies.filter(e => e.health > 0); particles = particles.filter(p => p.lifespan > 0); powerUps = powerUps.filter(p => p.y < canvas.height + 20); if (scoreMultiplier > 1) { scoreMultiplier -= 0.05 * deltaTime; if (scoreMultiplier < 1) scoreMultiplier = 1; } backgroundStars.forEach(s => { s.y += s.speed * deltaTime * gameSpeed; if (s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; } }); }
    function draw() { ctx.save(); if (screenShake > 0) { const shakeX = (Math.random() - 0.5) * screenShake; const shakeY = (Math.random() - 0.5) * screenShake; ctx.translate(shakeX, shakeY); } ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#fff'; backgroundStars.forEach(s => { ctx.globalAlpha = s.opacity; ctx.fillRect(s.x, s.y, s.size, s.size); }); ctx.globalAlpha = 1; if (screenFlashTimer > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${screenFlashTimer * 4})`; ctx.fillRect(0, 0, canvas.width, canvas.height); } if (player && player.skinRarity === 3 && gameSpeed < 1) { const grad = ctx.createRadialGradient(player.x, player.y, 50, player.x, player.y, canvas.width/2); grad.addColorStop(0, player.accentColor + '00'); grad.addColorStop(1, player.accentColor + '40'); ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height); } if (player && (gameState === 'playing' || gameState === 'gameOver')) { powerUps.forEach(p => p.draw(ctx)); player.draw(ctx); if (player.orbiters) player.orbiters.forEach(o => o.draw(ctx)); enemies.forEach(e => e.draw(ctx)); bullets.forEach(b => b.draw(ctx)); particles.forEach(p => p.draw(ctx)); } if (player && player.lives <= 1 && !player.isInvincible) { const alpha = 0.3 + Math.sin(lowHealthPulse) * 0.2; ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height); } ctx.restore(); updateUI(); }
    function updateUI() { scoreEl.textContent = `SCORE: ${Math.floor(score)}`; highScoreEl.textContent = `HIGH: ${Math.floor(highScore)}`; if (player) { let lifeText = ''; for(let i=0; i<player.lives; i++) lifeText += '‚ô•'; lifeInfoEl.textContent = lifeText; let specialText = ''; switch(selectedCharacterId) { case 'rift': specialText = `BLINK ${player.blinkCooldown > 0 ? Math.ceil(player.blinkCooldown) : 'RDY'}`; break; case 'phase': specialText = `DASH ${player.dashCooldown > 0 ? Math.ceil(player.dashCooldown) : 'RDY'}`; break; case 'echo': specialText = `PARRY ${player.parryTimer > 0 ? 'ON' : 'RDY'}`; break; case 'aegis': specialText = `SHIELD ${player.isShielding ? 'ON' : 'OFF'}`; break; default: for(let i=0; i<player.bombs; i++) specialText += '‚òÖ'; break; } bombInfoEl.textContent = specialText; } }
    function gameLoop(timestamp) { if (!lastTime) lastTime = timestamp; const deltaTime = Math.min(0.1, (timestamp - lastTime) / 1000); lastTime = timestamp; if (gameState === 'playing') update(deltaTime); draw(); animationFrameId = requestAnimationFrame(gameLoop); }
    function gameOver() { gameState = 'gameOver'; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } const scoreToShards = Math.floor(score / 500); const totalEarned = scoreToShards + waveClearBonus + bossKillBonus; chronoShards += totalEarned; if (score > highScore) highScore = score; const charData = characters[selectedCharacterId]; if(score > charData.highScore) charData.highScore = Math.floor(score); if(!charData.skins.mythic.unlocked && charData.highScore >= 1000000) { charData.skins.mythic.unlocked = true; setTimeout(() => alert(`üèÜ ${charData.name} Ïã†Ìôî Ïä§ÌÇ® Ìï¥Í∏à! üèÜ\n1,000,000Ï†ê Îã¨ÏÑ±ÏùÑ Ï∂ïÌïòÌï©ÎãàÎã§!`), 500); } saveData(); finalScoreEl.textContent = `FINAL SCORE: ${Math.floor(score)}`; shardsEarnedEl.innerHTML = `üíé +${scoreToShards} (Score)<br>üíé +${waveClearBonus} (Wave)<br>üíé +${bossKillBonus} (Boss)<br>TOTAL: üíé +${totalEarned}`; shardsEarnedEl.classList.add('animate'); setTimeout(() => shardsEarnedEl.classList.remove('animate'), 1000); draw(); gameOverScreen.style.display = 'flex'; }
    function resetGame() { score = 0; scoreMultiplier = 1; wave = 0; waveTimer = 0; gameSpeed = 1; waveClearBonus = 0; bossKillBonus = 0; screenShake = 0; enemies = []; bullets = []; particles = []; powerUps = []; player = new Player(); gameState = 'playing'; }
    function startOrRestartGame() { mainMenuScreen.style.display = 'none'; resetGame(); if (!animationFrameId) { lastTime = 0; animationFrameId = requestAnimationFrame(gameLoop); } }

    // --- 6. Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨ Î∞è UI ---
    function saveData() { localStorage.setItem('chronoBreakData_v5', JSON.stringify({ highScore, chronoShards, characters, upgrades, controlMode })); }
    function loadData() { const data = JSON.parse(localStorage.getItem('chronoBreakData_v5')); if (data) { highScore = data.highScore || 0; chronoShards = data.chronoShards || 0; controlMode = data.controlMode || 'keyboard'; if (data.upgrades) { Object.keys(upgrades).forEach(key => { if(data.upgrades[key]) Object.assign(upgrades[key], data.upgrades[key]); }); } if (data.characters) { Object.keys(characters).forEach(id => { if (data.characters[id]) { Object.assign(characters[id], data.characters[id]); } }); } } }
    function updateMainMenu() {
        shardDisplay.textContent = `üíé ${chronoShards}`; charListPanel.innerHTML = '';
        Object.keys(characters).forEach(id => { const char = characters[id]; const div = document.createElement('div'); div.className = 'char-portrait'; if (char.unlocked) { div.innerHTML = `<span class="char-icon" style="color:${SKIN_COLORS[id]['normal']}">${char.icon}</span><div class="char-portrait-info"><span class="char-name">${char.name}</span><span class="char-highscore">HI: ${char.highScore}</span></div>`; div.onclick = () => { selectedCharacterId = id; updateMainMenu(); }; if (id === selectedCharacterId) div.classList.add('selected'); } else { div.classList.add('locked'); div.innerHTML = `<span class="char-icon">?</span><div class="char-portrait-info"><span class="char-name">???</span></div>`; div.onclick = () => alert('Ï∫êÎ¶≠ÌÑ∞ ÎΩëÍ∏∞ÏóêÏÑú ÌöçÎìùÌï† Ïàò ÏûàÏäµÎãàÎã§.'); } charListPanel.appendChild(div); });
        const selectedCharData = characters[selectedCharacterId]; selectedCharDetailsEl.innerHTML = `<strong>${selectedCharData.name}</strong><br>${selectedCharData.desc}`; skinSelectionContainer.innerHTML = '';
        Object.keys(selectedCharData.skins).forEach(skinId => { const skinData = selectedCharData.skins[skinId]; const swatch = document.createElement('div'); swatch.className = `skin-swatch rarity-${skinId}`; swatch.style.backgroundColor = SKIN_COLORS[selectedCharacterId][skinId]; if (skinData.unlocked) { if (skinId === selectedCharData.selectedSkin) swatch.classList.add('selected'); swatch.onclick = () => { selectedCharData.selectedSkin = skinId; saveData(); updateMainMenu(); }; } else { swatch.classList.add('locked'); } skinSelectionContainer.appendChild(swatch); });
        upgradeSection.innerHTML = ''; Object.keys(upgrades).forEach(id => { const upg = upgrades[id]; const cost = upg.level < upg.maxLevel ? upg.cost[upg.level] : 'MAX'; const row = document.createElement('div'); row.className = 'upgrade-row'; row.innerHTML = `<span>${upg.name} (Lv.${upg.level})</span>`; const btn = document.createElement('button'); btn.textContent = `UP (üíé${cost})`; btn.disabled = upg.level >= upg.maxLevel || chronoShards < cost; btn.onclick = () => buyUpgrade(id); row.appendChild(btn); upgradeSection.appendChild(row); });
        const lockedChars = Object.values(characters).filter(c => !c.unlocked); charGachaButton.disabled = chronoShards < 1500 || lockedChars.length === 0;
        const lockedSkins = Object.values(characters).flatMap(c => c.unlocked ? Object.keys(c.skins).filter(s => !c.skins[s].unlocked && s !== 'mythic' && s !== 'normal') : []); skinGachaButton.disabled = chronoShards < 10000 || lockedSkins.length === 0;
        controlToggleButton.textContent = `Ïª®Ìä∏Î°§: ${controlMode === 'keyboard' ? 'ÌÇ§Î≥¥Îìú' : 'ÌÑ∞Ïπò'}`;
    }
    function buyUpgrade(id) { const upg = upgrades[id]; const cost = upg.cost[upg.level]; if (chronoShards >= cost && upg.level < upg.maxLevel) { chronoShards -= cost; upg.level++; playSound('itemGet'); saveData(); updateMainMenu(); } }
    function buyCharacterGacha() { const cost = 1500; if (chronoShards >= cost) { const locked = Object.keys(characters).filter(id => !characters[id].unlocked); if (locked.length > 0) { chronoShards -= cost; const unlockedId = locked[Math.floor(Math.random() * locked.length)]; characters[unlockedId].unlocked = true; alert(`‚ú® [Ï∫êÎ¶≠ÌÑ∞ Ìï¥Í∏à] ${characters[unlockedId].name} ÌöçÎìù! ‚ú®`); playSound('itemGet', 1.0); saveData(); updateMainMenu(); } else { alert('Î™®Îì† Ï∫êÎ¶≠ÌÑ∞Î•º Ìï¥Í∏àÌñàÏäµÎãàÎã§!'); } } else { alert(`ÏÉ§ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. (ÌïÑÏöî: üíé${cost})`); } }
    function buySkinGacha() { const cost = 10000; if (chronoShards >= cost) { const availableSkins = []; Object.keys(characters).forEach(charId => { const char = characters[charId]; if (char.unlocked) { Object.keys(char.skins).forEach(skinId => { if (skinId !== 'normal' && skinId !== 'mythic' && !char.skins[skinId].unlocked) { availableSkins.push({ charId, skinId }); } }); } }); if (availableSkins.length > 0) { chronoShards -= cost; const { charId, skinId } = availableSkins[Math.floor(Math.random() * availableSkins.length)]; characters[charId].skins[skinId].unlocked = true; const skinRarityName = skinId.charAt(0).toUpperCase() + skinId.slice(1); alert(`‚ú® [${skinRarityName}] ${characters[charId].name} Ïä§ÌÇ® ÌöçÎìù! ‚ú®`); playSound('itemGet', 1.0); saveData(); updateMainMenu(); } else { alert('Îçî Ïù¥ÏÉÅ ÎΩëÏùÑ Ïàò ÏûàÎäî Ïä§ÌÇ®Ïù¥ ÏóÜÏäµÎãàÎã§!'); } } else { alert(`ÏÉ§ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. (ÌïÑÏöî: üíé${cost})`); } }

    // --- 7. Ï¥àÍ∏∞Ìôî ---
    function init() {
        function resizeCanvas() { const aspectRatio = 9 / 16; let newWidth = window.innerWidth, newHeight = window.innerHeight; const windowRatio = newWidth / newHeight; if (windowRatio > aspectRatio) { newHeight = Math.min(newHeight, 1200); newWidth = newHeight * aspectRatio; } else { newWidth = Math.min(newWidth, 800); newHeight = newWidth / aspectRatio; } canvas.width = newWidth; canvas.height = newHeight; const scale = newWidth / 450; document.body.style.fontSize = `${scale}rem`; backgroundStars = []; for(let i=0; i<100; i++) { backgroundStars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 1, speed: Math.random() * 20 + 10, opacity: Math.random() * 0.5 + 0.2 }); } }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();
        const rootStyles = getComputedStyle(document.documentElement);
        colors.enemy1 = rootStyles.getPropertyValue('--enemy-color-1').trim(); colors.enemy2 = rootStyles.getPropertyValue('--enemy-color-2').trim(); colors.dasher = rootStyles.getPropertyValue('--enemy-dasher-color').trim(); colors.weaver = rootStyles.getPropertyValue('--enemy-weaver-color').trim(); colors.kamikaze = rootStyles.getPropertyValue('--enemy-kamikaze-color').trim(); colors.boss = rootStyles.getPropertyValue('--boss-color').trim(); colors.enemyBullet = rootStyles.getPropertyValue('--enemy-bullet-color').trim();
        colors.powerupP = rootStyles.getPropertyValue('--powerup-p-color').trim(); colors.powerupB = rootStyles.getPropertyValue('--powerup-b-color').trim(); colors.powerupC = rootStyles.getPropertyValue('--powerup-c-color').trim(); colors.powerupS = rootStyles.getPropertyValue('--powerup-s-color').trim();
        colors.sentinel = rootStyles.getPropertyValue('--enemy-sentinel-color').trim(); colors.bulwark = rootStyles.getPropertyValue('--enemy-bulwark-color').trim(); colors.barrier = rootStyles.getPropertyValue('--enemy-barrier-color').trim();
        loadData(); updateMainMenu(); initAudio();
        startGameButton.onclick = async () => { if (audioContext && audioContext.state === 'suspended') { await audioContext.resume(); } inputHandler.setup(); startOrRestartGame(); };
        charGachaButton.onclick = buyCharacterGacha;
        skinGachaButton.onclick = buySkinGacha;
        controlToggleButton.onclick = () => { controlMode = (controlMode === 'keyboard') ? 'touch' : 'keyboard'; saveData(); updateMainMenu(); };
        returnToMenuButton.onclick = () => { gameOverScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; updateMainMenu(); };
        highScoreEl.textContent = `HIGH: ${Math.floor(highScore)}`;
    }
    window.addEventListener('load', init);
    </script>
</body>
</html>
