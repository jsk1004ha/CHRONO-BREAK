<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>크로노 브레이크: EQUILIBRIUM</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d1a; --player-color: #00ffff; --player-blade-color: #f0f; --player-pulse-color: #ffc800;
            --enemy-color-1: #ff4d4d; --enemy-color-2: #ffcc00; --enemy-dasher-color: #f0a050; --enemy-weaver-color: #9d74e0; --enemy-kamikaze-color: #ffffff; --boss-color: #ff00ff;
            --bullet-color: #ffffff; --enemy-bullet-color: #ff80ff; /* ✨ 적 총알 색상 추가 */
            --powerup-p-color: #4dff4d; --powerup-b-color: #4da6ff; --powerup-c-color: #cc66ff; --powerup-s-color: #a9d4ff; /* ✨ 샤드 아이템 색상 추가 */
            --hud-color: #ffffff; --gauge-color: #00ffff; --gauge-bg-color: #33334d; --button-bg: rgba(255, 255, 255, 0.1); --button-border: rgba(255, 255, 255, 0.5); --shard-color: #a9d4ff;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-color); color: var(--hud-color); font-family: 'Press+Start+2P',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif; -webkit-tap-highlight-color: transparent; font-family: 'Press Start 2P', cursive; }
        #game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
        canvas { background-color: #000; border: 1px solid var(--button-border); touch-action: none; }
        .hud, .screen-overlay { text-shadow: 2px 2px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000; }
        .hud { position: absolute; width: 100%; padding: 15px 20px; font-size: 1em; line-height: 1.4; pointer-events: none; }
        #top-hud { top: 0; display: flex; justify-content: space-between; align-items: flex-start; }
        #bottom-hud { bottom: 0; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #chrono-gauge-container { width: 80%; height: 15px; background-color: var(--gauge-bg-color); border: 2px solid var(--button-border); border-radius: 10px; overflow: hidden; }
        #chrono-gauge-bar { width: 0%; height: 100%; background-color: var(--gauge-color); transition: width 0.1s linear; }
        #bomb-info, #life-info { font-size: 1.2em; }
        .mobile-control { position: absolute; bottom: 30px; width: 70px; height: 70px; background-color: var(--button-bg); border: 2px solid var(--button-border); border-radius: 50%; color: white; display: none; justify-content: center; align-items: center; font-size: 0.8em; user-select: none; z-index: 10; }
        #chrono-break-button { left: 30px; }
        #bomb-button { right: 30px; }
        .mobile-control.active { background-color: rgba(0, 255, 255, 0.5); }
        .screen-overlay { position: absolute; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 20; cursor: default; padding: 10px; }
        .screen-overlay h1 { font-size: 2.5em; line-height: 1.2; margin-bottom: 15px; }
        .screen-overlay p { font-size: 1em; margin: 5px 0; line-height: 1.5; }
        .screen-overlay button { padding: 10px 20px; font-size: 1em; font-weight: bold; color: var(--bg-color); background-color: var(--player-color); border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 0 15px var(--player-color); transition: transform 0.1s; margin-top: 10px; font-family: 'Press Start 2P', cursive; }
        .screen-overlay button:active { transform: scale(0.95); }
        .screen-overlay button:disabled { background-color: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        #main-menu-screen h1 { text-shadow: 2px 2px 0px var(--player-color), -2px -2px 0px var(--player-color), 2px -2px 0px var(--player-color), -2px 2px 0px var(--player-color); }
        #game-over-screen { display: none; }
        #game-over-screen h1 { text-shadow: 2px 2px 0px #ff0000, -2px -2px 0px #ff0000, 2px -2px 0px #ff0000, -2px 2px 0px #ff0000; }
        #shard-display { color: var(--shard-color); font-size: 1.2em; font-weight: bold; margin-bottom: 15px; }
        #shards-earned.animate { animation: pop-in 0.5s ease-out; }
        @keyframes pop-in { 0% { transform: scale(0.5); opacity: 0; } 80% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); } }
        #character-selection { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 15px; }
        .char-portrait { width: 90px; height: 120px; border: 3px solid var(--button-border); border-radius: 10px; cursor: pointer; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: all 0.2s; padding: 5px; background: rgba(0,0,0,0.2); }
        .char-portrait.selected { border-color: var(--player-color); transform: scale(1.1); box-shadow: 0 0 15px var(--player-color); }
        .char-portrait.locked { background-color: rgba(0,0,0,0.7); cursor: not-allowed; }
        .char-portrait.locked .char-name, .char-portrait.locked .char-desc { color: #888; }
        .char-icon { font-size: 1.8em; }
        .char-name { font-weight: bold; margin-top: 5px; font-size: 0.8em; }
        .char-desc { font-size: 0.6em; margin-top: 5px; color: #ccc; line-height: 1.2; }
        #upgrade-section { display: flex; flex-direction: column; gap: 8px; margin: 10px 0; font-size: 0.8em; }
        .upgrade-row { display: flex; justify-content: space-between; align-items: center; width: 320px; }
        #start-game-button { margin-top: 15px; padding: 15px 40px; font-size: 1.5em; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="main-menu-screen" class="screen-overlay">
            <h1>CHRONO BREAK</h1>
            <p id="shard-display">💎 0</p>
            <div id="character-selection"></div>
            <div id="upgrade-section"></div>
            <button id="gacha-button">뽑기 (💎2500)</button>
            <button id="start-game-button">START</button>
        </div>
        <div id="top-hud" class="hud">
            <div>
                <span id="score">SCORE: 0</span><br>
                <span id="high-score">HIGH: 0</span>
            </div>
            <div style="text-align: right;">
                <span id="life-info"></span><br>
                <span id="bomb-info"></span>
            </div>
        </div>
        <div id="bottom-hud" class="hud">
            <div id="chrono-gauge-container"><div id="chrono-gauge-bar"></div></div>
        </div>
        <div id="chrono-break-button" class="mobile-control">BREAK</div>
        <div id="bomb-button" class="mobile-control">BOMB</div>
        <div id="game-over-screen" class="screen-overlay">
            <h1>GAME OVER</h1>
            <p id="final-score"></p>
            <p id="shards-earned"></p>
            <button id="return-to-menu-button">MENU</button>
        </div>
    </div>

    <script>
    // --- 1. 전역 변수 및 상수 초기화 ---
    const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
    const mainMenuScreen = document.getElementById('main-menu-screen'), gameOverScreen = document.getElementById('game-over-screen');
    const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('high-score'), lifeInfoEl = document.getElementById('life-info'), bombInfoEl = document.getElementById('bomb-info'), chronoGaugeBarEl = document.getElementById('chrono-gauge-bar');
    const shardDisplay = document.getElementById('shard-display'), charSelectionContainer = document.getElementById('character-selection'), upgradeSection = document.getElementById('upgrade-section');
    const gachaButton = document.getElementById('gacha-button'), startGameButton = document.getElementById('start-game-button'), returnToMenuButton = document.getElementById('return-to-menu-button');
    const finalScoreEl = document.getElementById('final-score'), shardsEarnedEl = document.getElementById('shards-earned');
    const mobileChronoButton = document.getElementById('chrono-break-button'), mobileBombButton = document.getElementById('bomb-button');
    let gameState = 'mainMenu', isMobile = false, gameSpeed = 1, lastTime = 0, animationFrameId = null;
    let score = 0, highScore = 0, scoreMultiplier = 1, wave = 0, waveTimer = 0;
    let player, enemies = [], bullets = [], particles = [], powerUps = [];
    const colors = {};
    let chronoShards = 0, waveClearBonus = 0, bossKillBonus = 0;
    let selectedCharacterId = 'stinger';
    let characters = { stinger: { name: '스팅어', icon: '▶', unlocked: true, desc: '집중형 표준 샷' }, guardian: { name: '가디언', icon: '❖', unlocked: false, desc: '광역 샷, 폭탄+1' }, spectre: { name: '스펙터', icon: '⬟', unlocked: false, desc: '유도탄, 게이지+' }, pulse: { name: '펄스', icon: '◎', unlocked: false, desc: '근접 파동, 처치 시 게이지 회복' }, blade: { name: '블레이드', icon: '▲', unlocked: false, desc: '관통 공격, 생명 1, 점수 2배' } };
    let upgrades = { power: { name: '시작 파워', level: 0, maxLevel: 3, cost: [1000, 3000, 7000] }, bombs: { name: '시작 폭탄', level: 0, maxLevel: 2, cost: [2000, 5000] }, gauge: { name: '게이지 효율', level: 0, maxLevel: 4, cost: [1500, 3500, 6000, 9000] }, magnet: { name: '아이템 자석', level: 0, maxLevel: 1, cost: [10000] } };

    // --- 2. 사운드 시스템 ---
    let audioContext; const audioBuffers = {};
    const soundAssets = { shoot: 'data:audio/wav;base64,UklGRlgAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAP//AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8=', explosion: 'data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSgAAAA+Pj8/Pz4+Pj4+Pj49PT09PTw8PDs7Ozo6Ojk5OTg4ODc3Njc2NjU1NTQ0NDMzMzIyMjExMTAwLy8uLSwrKikoJyYmJSUlJCQkIyIiISAgHx4eHBsaGRgXFhUUExITEREOBwgFBAIB', graze: 'data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAA//8BAAECBQQHCAkKCw0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0A=', playerHit: 'data:audio/wav;base64,UklGRmAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAABAAAD8AP4A/gD9APwA+wD5APgA9wD0APMA8gDxAPAA7wDsAOsA6ADnAOYA4wDiAOEA3wDcANsA2ADRANAAzwDMAssCyQLEAsECwQHCAb8BvgG9AbwBvQG+Ab8BwgHCAsECwQLFAsYCyQLLAMwA0ADSANkA3ADeAOAA4wDnAOoA7QDyAPUA+gD/AAQBCgEQARYBGgEcASQBKgEuATMBPAE/AUQBSgFOAVIBVwFYAVwBXgFiAWgBbAFwAW8BcgF3AXgBewF9AX8BfwF+AXwBcgFvAWwBagFkAWQBZAFhAVgBUwFPAUkBRQFBAT4BOgEwASoBJwEhARwBFgEOAQsBBgECAP4A+wD0AO0A5wDhANkA0AC/AbwBsgGnAZwBlgGRAZAAkAGSAZgBoQGwAbwBwwHNAeYB+gIIAhMCHQImAiwCMAI3Aj4CRQJMAloCXQJgAmYCcAJ2AoACjgKiAq4CwgLPAtgC4gLrAvUC+wL+AwIDBwMLAxcDGgMiAykDMANAA0sDWANgA2gDcAN8A4gDkQOcA6sDtQO/A8wD3APqA/0DAwQIBhEKDxQVGh0gIycoMDM5PEBHS1JcYW5xfISQlp+lrsbT3+n6/w==', itemGet: 'data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YRoAAAAaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc=', chronoStart: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAPz49Ozg1MzExLy0rKCcmJSQjIiAfHhsZFRMREQ4HCAUEAgE=', chronoEnd: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAAgQFBwgODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygp' };
    async function initAudio() { if (audioContext) return; try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); const soundNames = Object.keys(soundAssets); for (const name of soundNames) { const response = await fetch(soundAssets[name]); const arrayBuffer = await response.arrayBuffer(); const audioBuffer = await audioContext.decodeAudioData(arrayBuffer); audioBuffers[name] = audioBuffer; } } catch (e) { console.error("Web Audio API is not supported", e); } }
    function playSound(name) { if (!audioContext || !audioBuffers[name] || audioContext.state === 'suspended') return; const source = audioContext.createBufferSource(); source.buffer = audioBuffers[name]; const gainNode = audioContext.createGain(); gainNode.gain.value = name === 'shoot' ? 0.3 : 0.7; source.connect(gainNode); gainNode.connect(audioContext.destination); source.start(0); }

    // --- 3. 클래스 정의 ---
    class Player {
        constructor() {
            this.x = canvas.width / 2; this.y = canvas.height - 80; this.size = 12; this.hitboxSize = 4; this.grazeRadius = 40; this.speed = 280;
            this.shootCooldown = 0; this.isInvincible = false; this.invincibleTimer = 0; this.chronoGauge = 0; this.chronoGaugeMax = 100;
            this.power = 1 + upgrades.power.level; this.bombs = 3 + upgrades.bombs.level + (selectedCharacterId === 'guardian' ? 1 : 0);
            this.lives = (selectedCharacterId === 'blade') ? 1 : 3;
            switch(selectedCharacterId) { case 'blade': this.color = colors.playerBlade; break; case 'pulse': this.color = colors.playerPulse; break; default: this.color = colors.player; break; }
        }
        update(deltaTime, input) {
            let moveX = 0, moveY = 0; if (input.keys.ArrowLeft || input.keys.a) moveX -= 1; if (input.keys.ArrowRight || input.keys.d) moveX += 1; if (input.keys.ArrowUp || input.keys.w) moveY -= 1; if (input.keys.ArrowDown || input.keys.s) moveY += 1;
            if (isMobile && input.touch.active) { const dx = input.touch.x - this.x, dy = input.touch.y - this.y, dist = Math.hypot(dx, dy); if (dist > 1) { moveX = dx / dist; moveY = dy / dist; } }
            const effectiveSpeed = this.speed * deltaTime * (gameSpeed < 1 ? 1.5 : 1); this.x += moveX * effectiveSpeed; this.y += moveY * effectiveSpeed;
            this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            this.shootCooldown -= deltaTime; if (this.shootCooldown <= 0) { this.shoot(); this.shootCooldown = 0.12; }
            if (this.isInvincible) { this.invincibleTimer -= deltaTime; if (this.invincibleTimer <= 0) this.isInvincible = false; }
            const gaugeConsumption = 25 * (1 - (upgrades.gauge.level * 0.1));
            if ((input.keys.Shift || input.touch.chronoActive) && this.chronoGauge > 0) { if(gameSpeed === 1) playSound('chronoStart'); gameSpeed = 0.25; this.chronoGauge -= gaugeConsumption * deltaTime; if (this.chronoGauge < 0) this.chronoGauge = 0; } else { if(gameSpeed < 1) playSound('chronoEnd'); gameSpeed = 1; }
            if ((input.keys.x || input.touch.bombPressed) && this.bombs > 0) { input.keys.x = false; input.touch.bombPressed = false; this.useBomb(); }
        }
        draw(ctx) { if (this.isInvincible && Math.floor(this.invincibleTimer * 10) % 2 === 0) return; ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(this.x, this.y - this.size); ctx.lineTo(this.x - this.size / 1.5, this.y + this.size / 2); ctx.lineTo(this.x + this.size / 1.5, this.y + this.size / 2); ctx.closePath(); ctx.fill(); if (gameSpeed < 1) { ctx.strokeStyle = this.color; ctx.globalAlpha = 0.5; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x, this.y, this.grazeRadius, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1.0; } }
        shoot() {
            playSound('shoot'); const p = Math.min(this.power, 5);
            switch (selectedCharacterId) {
                case 'blade': bullets.push(new Bullet(this.x, this.y, -90, 1200, 'player', { isPiercing: true, width: 4 + p, height: 40 })); break;
                case 'pulse': bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { isWave: true, size: 15 + p * 5, lifespan: 0.2 })); break;
                case 'spectre': bullets.push(new Bullet(this.x, this.y, -90, 400, 'player', { isHoming: true })); if (p > 2) bullets.push(new Bullet(this.x - 15, this.y, -90, 400, 'player', { isHoming: true })); if (p > 4) bullets.push(new Bullet(this.x + 15, this.y, -90, 400, 'player', { isHoming: true })); break;
                case 'guardian': bullets.push(new Bullet(this.x, this.y, -90, 700, 'player')); for(let i=1; i<=Math.floor(p/2); i++) { bullets.push(new Bullet(this.x, this.y, -90 - i * 15, 700, 'player')); bullets.push(new Bullet(this.x, this.y, -90 + i * 15, 700, 'player')); } break;
                default: if (p === 1) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player')); } else if (p === 2) { bullets.push(new Bullet(this.x - 5, this.y, -90, 800, 'player')); bullets.push(new Bullet(this.x + 5, this.y, -90, 800, 'player')); } else if (p === 3) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player')); bullets.push(new Bullet(this.x, this.y, -85, 800, 'player')); bullets.push(new Bullet(this.x, this.y, -95, 800, 'player')); } else if (p === 4) { bullets.push(new Bullet(this.x - 8, this.y, -90, 800, 'player')); bullets.push(new Bullet(this.x + 8, this.y, -90, 800, 'player')); bullets.push(new Bullet(this.x - 4, this.y, -85, 800, 'player')); bullets.push(new Bullet(this.x + 4, this.y, -95, 800, 'player')); } else if (p >= 5) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player')); bullets.push(new Bullet(this.x, this.y, -80, 800, 'player')); bullets.push(new Bullet(this.x, this.y, -100, 800, 'player')); bullets.push(new Bullet(this.x - 10, this.y, -90, 800, 'player')); bullets.push(new Bullet(this.x + 10, this.y, -90, 800, 'player')); } break;
            }
        }
        takeHit() { if (this.isInvincible) return; playSound('playerHit'); this.lives--; this.power = Math.max(1, this.power - 1); this.isInvincible = true; this.invincibleTimer = 2; createExplosion(this.x, this.y, this.color, 30); if (this.lives < 0) { gameOver(); } }
        addChronoGauge(amount) { const multiplier = selectedCharacterId === 'spectre' ? 1.5 : 1; this.chronoGauge = Math.min(this.chronoGaugeMax, this.chronoGauge + amount * multiplier); }
        useBomb() { if (this.bombs <= 0) return; this.bombs--; playSound('explosion'); this.isInvincible = true; this.invincibleTimer = 1.0; bullets = bullets.filter(b => b.owner !== 'enemy'); enemies.forEach(e => e.takeDamage(50)); createScreenFlash(); }
    }

    class Bullet {
        constructor(x, y, angle, speed, owner, special = {}) {
            this.x = x; this.y = y; this.owner = owner; this.special = special;
            this.color = (owner === 'player' && player) ? player.color : colors.enemyBullet;
            if (special.isWave) { this.size = special.size; this.lifespan = special.lifespan; } else if (special.isPiercing) { this.width = special.width; this.height = special.height; this.hitEnemies = new Set(); } else { this.size = 5; }
            const rad = angle * Math.PI / 180; this.vx = Math.cos(rad) * speed; this.vy = Math.sin(rad) * speed; this.grazed = false; this.homingTarget = null;
        }
        update(deltaTime) {
            if (this.special.isHoming && this.owner === 'player') { if (!this.homingTarget || this.homingTarget.health <= 0) { let closestEnemy = null, minDist = Infinity; for (const enemy of enemies) { const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < minDist) { minDist = dist; closestEnemy = enemy; } } this.homingTarget = closestEnemy; } if (this.homingTarget) { const angleToTarget = Math.atan2(this.homingTarget.y - this.y, this.homingTarget.x - this.x); this.vx += Math.cos(angleToTarget) * 2000 * deltaTime; this.vy += Math.sin(angleToTarget) * 2000 * deltaTime; const speed = Math.hypot(this.vx, this.vy), maxSpeed = 400; if (speed > maxSpeed) { this.vx = (this.vx / speed) * maxSpeed; this.vy = (this.vy / speed) * maxSpeed; } } }
            if (this.special.isWave) { this.lifespan -= deltaTime; }
            this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed;
        }
        draw(ctx) {
            ctx.fillStyle = this.color; ctx.beginPath();
            if (this.special.isWave) { ctx.globalAlpha = this.lifespan / this.special.lifespan; ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.globalAlpha = 1; }
            else if (this.special.isPiercing) { ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); }
            else { ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); }
            ctx.fill();
        }
    }

    class Enemy {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; const difficulty = 1 + wave * 0.1; this.init(difficulty); }
        init(difficulty) {
            this.shootTimer = Math.random() * 2 + 1; this.bulletSpeed = 250 * (1 + wave * 0.05);
            switch(this.type) { case 'dasher': this.size = 12; this.health = 10 * difficulty; this.color = colors.dasher; this.speed = 300; this.scoreValue = 150; this.vy = this.speed; this.vx = Math.random() > 0.5 ? 100 : -100; break; case 'weaver': this.size = 18; this.health = 25 * difficulty; this.color = colors.weaver; this.speed = 80; this.scoreValue = 250; this.baseX = this.x; this.angle = 0; break; case 'kamikaze': this.size = 15; this.health = 5 * difficulty; this.color = colors.kamikaze; this.speed = 150; this.scoreValue = 200; break; case 'basic': this.size = 15; this.health = 15 * difficulty; this.color = colors.enemy1; this.speed = 100; this.scoreValue = 100; break; case 'shooter': this.size = 20; this.health = 40 * difficulty; this.color = colors.enemy2; this.speed = 60; this.scoreValue = 300; break; case 'boss': this.size = 50; this.health = (2000 + wave * 500) * difficulty; this.maxHealth = this.health; this.color = colors.boss; this.speed = 50; this.scoreValue = 10000; this.pattern = 'entry'; this.patternTimer = 0; this.bulletSpeed *= 1.2; break; }
        }
        update(deltaTime) {
            switch(this.type) { case 'dasher': this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed; break; case 'weaver': this.y += this.speed * deltaTime * gameSpeed; this.angle += 3 * deltaTime * gameSpeed; this.x = this.baseX + Math.sin(this.angle) * 80; break; case 'kamikaze': if (player) { const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angleToPlayer) * this.speed * deltaTime * gameSpeed; this.y += Math.sin(angleToPlayer) * this.speed * deltaTime * gameSpeed; if (Math.hypot(this.x - player.x, this.y - player.y) < this.size + player.hitboxSize) { this.health = 0; player.takeHit(); } } break; default: this.y += this.speed * deltaTime * gameSpeed; break; }
            this.shootTimer -= deltaTime * gameSpeed; if (this.shootTimer <= 0) this.shoot();
            if (this.type === 'boss') { const healthRatio = this.health / this.maxHealth; let newPattern = null; if (healthRatio <= 0.25) newPattern = 'desperate'; else if (healthRatio <= 0.5) newPattern = 'phase3'; else if (healthRatio <= 0.75) newPattern = 'phase2'; else newPattern = 'phase1'; if (this.pattern !== newPattern) { this.pattern = newPattern; this.patternTimer = 0; } this.patternTimer += deltaTime; if (this.y < 150) { this.y += this.speed * deltaTime; } else {this.y = 150;} }
            if (this.y > canvas.height + this.size) this.health = 0;
        }
        draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); if (this.type === 'basic') { ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2); } else { const sides = this.type === 'shooter' ? 6 : this.type === 'boss' ? 8 : 5; for (let i = 0; i < sides; i++) { const angle = (i / sides) * Math.PI * 2, xPos = this.x + this.size * Math.cos(angle), yPos = this.y + this.size * Math.sin(angle); if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos); } } ctx.closePath(); ctx.fill(); if(this.type === 'boss') { const barWidth = canvas.width * 0.8, barX = (canvas.width - barWidth) / 2; ctx.fillStyle = 'rgba(50,50,50,0.8)'; ctx.fillRect(barX, 10, barWidth, 10); ctx.fillStyle = this.color; ctx.fillRect(barX, 10, barWidth * (this.health / this.maxHealth), 10); } }
        shoot() {
            if (!player) return; const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x) * 180 / Math.PI;
            switch(this.type) {
                case 'dasher': break;
                case 'weaver': bullets.push(new Bullet(this.x, this.y, this.angle * 180 / Math.PI, this.bulletSpeed, 'enemy')); this.shootTimer = 1.5; break;
                case 'basic': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed, 'enemy')); this.shootTimer = 2.5; break;
                case 'shooter': for (let i = -1; i <= 1; i++) { bullets.push(new Bullet(this.x, this.y, angleToPlayer + i * 15, this.bulletSpeed * 0.8, 'enemy')); } this.shootTimer = 2.0; break;
                case 'boss':
                    switch(this.pattern) {
                        case 'desperate': for (let i = 0; i < 2; i++) bullets.push(new Bullet(this.x, this.y, angleToPlayer + Math.random()*20 - 10, this.bulletSpeed * 1.5, 'enemy')); this.shootTimer = 0.08; break;
                        case 'phase3': for (let i = 0; i < 18; i++) bullets.push(new Bullet(this.x, this.y, i * 20 + this.patternTimer * 20, this.bulletSpeed * 1.2, 'enemy')); this.shootTimer = 0.4; break;
                        case 'phase2': for (let i = 0; i < 8; i++) bullets.push(new Bullet(this.x, this.y, angleToPlayer - 35 + i * 10, this.bulletSpeed, 'enemy')); this.shootTimer = 0.8; break;
                        case 'phase1': bullets.push(new Bullet(this.x, this.y, this.patternTimer * 50, this.bulletSpeed * 0.9, 'enemy')); bullets.push(new Bullet(this.x, this.y, -this.patternTimer * 50, this.bulletSpeed * 0.9, 'enemy')); this.shootTimer = 0.1; break;
                    } break;
            }
        }
        takeDamage(damage) {
            this.health -= damage;
            if (this.health <= 0) {
                const scoreBonus = selectedCharacterId === 'blade' ? 2 : 1; score += this.scoreValue * Math.floor(scoreMultiplier) * scoreBonus;
                if (selectedCharacterId === 'pulse' && player) player.addChronoGauge(1);
                if (this.type === 'boss') bossKillBonus += 250;
                createExplosion(this.x, this.y, this.color, 20); playSound('explosion');
                const dropChance = this.type === 'boss' ? 1.0 : 0.15;
                if (Math.random() < dropChance) { let itemType = 'P'; const rand = Math.random(); if (rand < 0.25) itemType = 'B'; else if (rand < 0.5) itemType = 'C'; powerUps.push(new PowerUpItem(this.x, this.y, itemType)); }
                else if (Math.random() < 0.02) { powerUps.push(new PowerUpItem(this.x, this.y, 'S')); }
            }
        }
    }
    class Particle { constructor(x, y, color, size) { this.x = x; this.y = y; this.size = Math.random() * size + 2; this.color = color; this.lifespan = 1; this.vx = (Math.random() - 0.5) * 150; this.vy = (Math.random() - 0.5) * 150; } update(deltaTime) { this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed; this.lifespan -= deltaTime; } draw(ctx) { ctx.globalAlpha = this.lifespan; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; } }
    class PowerUpItem {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.size = 12; this.speed = 80; switch(type) { case 'P': this.color = colors.powerupP; break; case 'B': this.color = colors.powerupB; break; case 'C': this.color = colors.powerupC; break; case 'S': this.color = colors.powerupS; break; } }
        update(deltaTime) { if (upgrades.magnet.level > 0 && player) { const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angleToPlayer) * 300 * deltaTime; this.y += Math.sin(angleToPlayer) * 300 * deltaTime; } else { this.y += this.speed * deltaTime * gameSpeed; } }
        draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'white'; ctx.font = 'bold 10px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const symbol = this.type === 'S' ? '💎' : this.type; ctx.fillText(symbol, this.x, this.y+1); }
    }

    // --- 4. 핵심 로직 및 게임 루프 ---
    const inputHandler = { keys: {}, touch: { x: 0, y: 0, active: false, chronoActive: false, bombPressed: false }, setup() { isMobile = navigator.maxTouchPoints > 0 || 'ontouchstart' in window; if (isMobile) { document.querySelectorAll('.mobile-control').forEach(el => el.style.display = 'flex'); canvas.addEventListener('touchstart', this.handleTouch.bind(this)); canvas.addEventListener('touchmove', this.handleTouch.bind(this)); canvas.addEventListener('touchend', e => { this.touch.active = false; }); mobileChronoButton.addEventListener('touchstart', e => { e.preventDefault(); this.touch.chronoActive = true; mobileChronoButton.classList.add('active'); }); mobileChronoButton.addEventListener('touchend', e => { e.preventDefault(); this.touch.chronoActive = false; mobileChronoButton.classList.remove('active'); }); mobileBombButton.addEventListener('touchstart', e => { e.preventDefault(); this.touch.bombPressed = true; mobileBombButton.classList.add('active'); }); mobileBombButton.addEventListener('touchend', e => { e.preventDefault(); mobileBombButton.classList.remove('active'); }); } else { document.addEventListener('keydown', e => { this.keys[e.key] = true; }); document.addEventListener('keyup', e => { this.keys[e.key] = false; }); } }, handleTouch(e) { e.preventDefault(); this.touch.active = true; const rect = canvas.getBoundingClientRect(); this.touch.x = e.touches[0].clientX - rect.left; this.touch.y = e.touches[0].clientY - rect.top; } };
    function checkCollisions() {
        for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (!b || b.owner !== 'player') continue; for (let j = enemies.length - 1; j >= 0; j--) { const e = enemies[j]; if (!e) continue; const dist = Math.hypot(b.x - e.x, b.y - e.y); if (dist < e.size + (b.special.isWave ? b.size : (b.size || 5))) { if (b.special.isPiercing) { if (b.hitEnemies.has(e)) continue; b.hitEnemies.add(e); } e.takeDamage(10 + player.power); if (!b.special.isPiercing && !b.special.isWave) { bullets.splice(i, 1); break; } } } }
        if (player && !player.isInvincible) { for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (!b || b.owner !== 'enemy') continue; if (!b.grazed) { const grazeDist = Math.hypot(b.x - player.x, b.y - player.y); if (grazeDist < player.grazeRadius + b.size) { b.grazed = true; scoreMultiplier += 0.1; player.addChronoGauge(3); playSound('graze'); } } const hitDist = Math.hypot(b.x - player.x, b.y - player.y); if (hitDist < player.hitboxSize + b.size) { player.takeHit(); bullets.splice(i, 1); scoreMultiplier = 1; break; } } }
        for (let i = powerUps.length - 1; i >= 0; i--) { const p = powerUps[i]; if (player) { const dist = Math.hypot(p.x - player.x, p.y - player.y); if (dist < player.size + p.size + (upgrades.magnet.level > 0 ? 50 : 0)) { playSound('itemGet'); switch(p.type) { case 'P': player.power++; break; case 'B': player.bombs++; break; case 'C': player.addChronoGauge(50); break; case 'S': chronoShards += 50 + Math.floor(Math.random() * 51); updateMainMenu(); break; } powerUps.splice(i, 1); } } }
    }
    function spawnEnemies(deltaTime) { waveTimer += deltaTime; const waveDuration = 45; if (waveTimer > waveDuration) { wave++; waveTimer = 0; waveClearBonus += 10; if (wave > 0 && wave % 3 === 0 && !enemies.some(e => e.type === 'boss')) { enemies.push(new Enemy(canvas.width / 2, -50, 'boss')); return; } } if (!enemies.some(e => e.type === 'boss')) { const spawnRate = 0.03 * (1 + wave * 0.20) * gameSpeed; if (Math.random() < spawnRate) { const x = Math.random() * canvas.width; const rand = Math.random(); let type = 'basic'; if (wave > 1 && rand < 0.2) type = 'dasher'; else if (wave > 2 && rand < 0.4) type = 'weaver'; else if (wave > 3 && rand < 0.5) type = 'kamikaze'; else if (rand < 0.7) type = 'shooter'; enemies.push(new Enemy(x, -20, type)); } } }
    function createExplosion(x, y, color, count) { for (let i = 0; i < count; i++) { particles.push(new Particle(x, y, color, 5)); } }
    let screenFlashTimer = 0; function createScreenFlash() { screenFlashTimer = 0.2; } function updateScreenFlash(deltaTime) { if (screenFlashTimer > 0) { screenFlashTimer -= deltaTime; } }
    function update(deltaTime) { if (gameState !== 'playing' || !player) return; player.update(deltaTime, inputHandler); enemies.forEach(e => e.update(deltaTime)); bullets.forEach(b => b.update(deltaTime)); particles.forEach(p => p.update(deltaTime)); powerUps.forEach(p => p.update(deltaTime)); checkCollisions(); spawnEnemies(deltaTime); bullets = bullets.filter(b => b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50 && (!b.lifespan || b.lifespan > 0)); enemies = enemies.filter(e => e.health > 0); particles = particles.filter(p => p.lifespan > 0); powerUps = powerUps.filter(p => p.y < canvas.height + 20); if (scoreMultiplier > 1) { scoreMultiplier -= 0.05 * deltaTime; if (scoreMultiplier < 1) scoreMultiplier = 1; } updateScreenFlash(deltaTime); }
    function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); if (screenFlashTimer > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${screenFlashTimer * 4})`; ctx.fillRect(0, 0, canvas.width, canvas.height); } if (player && (gameState === 'playing' || gameState === 'gameOver')) { powerUps.forEach(p => p.draw(ctx)); player.draw(ctx); enemies.forEach(e => e.draw(ctx)); bullets.forEach(b => b.draw(ctx)); particles.forEach(p => p.draw(ctx)); } updateUI(); }
    function updateUI() { scoreEl.textContent = `SCORE: ${Math.floor(score)}`; highScoreEl.textContent = `HIGH: ${Math.floor(highScore)}`; if (player) { let lifeText = ''; for(let i=0; i<player.lives; i++) lifeText += '♥'; lifeInfoEl.textContent = lifeText; let bombText = ''; for(let i=0; i<player.bombs; i++) bombText += '★'; bombInfoEl.textContent = bombText; chronoGaugeBarEl.style.width = `${player.chronoGauge}%`; } }
    function gameLoop(timestamp) { if (!lastTime) { lastTime = timestamp; } const deltaTime = Math.min(0.1, (timestamp - lastTime) / 1000); lastTime = timestamp; if (gameState === 'playing') { update(deltaTime); } draw(); animationFrameId = requestAnimationFrame(gameLoop); }
    function gameOver() { gameState = 'gameOver'; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } const scoreToShards = Math.floor(score / 500); const totalEarned = scoreToShards + waveClearBonus + bossKillBonus; chronoShards += totalEarned; if (score > highScore) { highScore = score; } saveData(); finalScoreEl.textContent = `FINAL SCORE: ${Math.floor(score)}`; shardsEarnedEl.innerHTML = `💎 +${scoreToShards} (Score)<br>💎 +${waveClearBonus} (Wave)<br>💎 +${bossKillBonus} (Boss)<br>TOTAL: 💎 +${totalEarned}`; shardsEarnedEl.classList.add('animate'); setTimeout(() => shardsEarnedEl.classList.remove('animate'), 1000); draw(); gameOverScreen.style.display = 'flex'; }
    function resetGame() { score = 0; scoreMultiplier = 1; wave = 0; waveTimer = 0; gameSpeed = 1; waveClearBonus = 0; bossKillBonus = 0; enemies = []; bullets = []; particles = []; powerUps = []; player = new Player(); gameState = 'playing'; }
    function startOrRestartGame() { mainMenuScreen.style.display = 'none'; resetGame(); if (!animationFrameId) { lastTime = 0; animationFrameId = requestAnimationFrame(gameLoop); } }

    // --- 6. 데이터 관리 및 UI ---
    function saveData() { localStorage.setItem('chronoBreakData', JSON.stringify({ highScore, chronoShards, characters, upgrades })); }
    function loadData() { const data = JSON.parse(localStorage.getItem('chronoBreakData')); if (data) { highScore = data.highScore || 0; chronoShards = data.chronoShards || 0; if(data.characters) { for(const key in data.characters) { if(characters[key]) Object.assign(characters[key], data.characters[key]); } } if(data.upgrades) { for(const key in data.upgrades) { if(upgrades[key]) Object.assign(upgrades[key], data.upgrades[key]); } } } }
    function updateMainMenu() {
        shardDisplay.textContent = `💎 ${chronoShards}`;
        charSelectionContainer.innerHTML = '';
        Object.keys(characters).forEach(id => { const char = characters[id]; const div = document.createElement('div'); div.className = 'char-portrait'; if (char.unlocked) { div.innerHTML = `<span class="char-icon">${char.icon}</span><span class="char-name">${char.name}</span><p class="char-desc">${char.desc}</p>`; div.onclick = () => { selectedCharacterId = id; updateMainMenu(); }; if (id === selectedCharacterId) div.classList.add('selected'); } else { div.classList.add('locked'); div.innerHTML = `<span class="char-icon">?</span><span class="char-name">???</span>`; } charSelectionContainer.appendChild(div); });
        upgradeSection.innerHTML = '';
        Object.keys(upgrades).forEach(id => { const upg = upgrades[id]; const cost = upg.level < upg.maxLevel ? upg.cost[upg.level] : 'MAX'; const row = document.createElement('div'); row.className = 'upgrade-row'; row.innerHTML = `<span>${upg.name} (Lv.${upg.level})</span>`; const btn = document.createElement('button'); btn.textContent = `UP (💎${cost})`; btn.disabled = upg.level >= upg.maxLevel || chronoShards < cost; btn.onclick = () => buyUpgrade(id); row.appendChild(btn); upgradeSection.appendChild(row); });
        const lockedChars = Object.values(characters).filter(c => !c.unlocked); gachaButton.disabled = chronoShards < 2500 || lockedChars.length === 0;
    }
    function buyUpgrade(id) { const upg = upgrades[id]; const cost = upg.cost[upg.level]; if (chronoShards >= cost && upg.level < upg.maxLevel) { chronoShards -= cost; upg.level++; playSound('itemGet'); saveData(); updateMainMenu(); } }
    function buyGacha() { if (chronoShards >= 2500) { const lockedChars = Object.keys(characters).filter(id => !characters[id].unlocked); if (lockedChars.length > 0) { chronoShards -= 2500; const unlockedCharId = lockedChars[Math.floor(Math.random() * lockedChars.length)]; characters[unlockedCharId].unlocked = true; alert(`✨ ${characters[unlockedCharId].name} 캐릭터 해금! ✨`); playSound('itemGet'); saveData(); updateMainMenu(); } } }

    // --- 7. 초기화 ---
    function init() {
        function resizeCanvas() { const aspectRatio = 9 / 16; let newWidth = window.innerWidth, newHeight = window.innerHeight; const windowRatio = newWidth / newHeight; if (windowRatio > aspectRatio) { newHeight = Math.min(newHeight, 1200); newWidth = newHeight * aspectRatio; } else { newWidth = Math.min(newWidth, 800); newHeight = newWidth / aspectRatio; } canvas.width = newWidth; canvas.height = newHeight; const scale = newWidth / 450; document.body.style.fontSize = `${scale}rem`; }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();
        const rootStyles = getComputedStyle(document.documentElement);
        colors.player = rootStyles.getPropertyValue('--player-color').trim(); colors.playerBlade = rootStyles.getPropertyValue('--player-blade-color').trim(); colors.playerPulse = rootStyles.getPropertyValue('--player-pulse-color').trim();
        colors.enemy1 = rootStyles.getPropertyValue('--enemy-color-1').trim(); colors.enemy2 = rootStyles.getPropertyValue('--enemy-color-2').trim(); colors.dasher = rootStyles.getPropertyValue('--enemy-dasher-color').trim(); colors.weaver = rootStyles.getPropertyValue('--enemy-weaver-color').trim(); colors.kamikaze = rootStyles.getPropertyValue('--enemy-kamikaze-color').trim(); colors.boss = rootStyles.getPropertyValue('--boss-color').trim();
        colors.bullet = rootStyles.getPropertyValue('--bullet-color').trim(); colors.enemyBullet = rootStyles.getPropertyValue('--enemy-bullet-color').trim();
        colors.powerupP = rootStyles.getPropertyValue('--powerup-p-color').trim(); colors.powerupB = rootStyles.getPropertyValue('--powerup-b-color').trim(); colors.powerupC = rootStyles.getPropertyValue('--powerup-c-color').trim(); colors.powerupS = rootStyles.getPropertyValue('--powerup-s-color').trim();
        loadData(); updateMainMenu(); inputHandler.setup(); initAudio();
        startGameButton.onclick = async () => { if (audioContext && audioContext.state === 'suspended') { await audioContext.resume(); } startOrRestartGame(); };
        gachaButton.onclick = buyGacha;
        returnToMenuButton.onclick = () => { gameOverScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; updateMainMenu(); };
        highScoreEl.textContent = `HIGH: ${Math.floor(highScore)}`;
    }
    
    window.addEventListener('load', init);
    </script>
</body>
</html>
