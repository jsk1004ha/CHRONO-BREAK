<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÌÅ¨Î°úÎÖ∏ Î∏åÎ†àÏù¥ÌÅ¨</title>
    <link rel="icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbB8AIAAwAASQAB2Cj0NAAAAABJRU5ErkJggg==">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d1a; --player-color: #00ffff;
            --enemy-color-1: #ff4d4d; --enemy-color-2: #ffcc00; --enemy-dasher-color: #f0a050; --enemy-weaver-color: #9d74e0; --enemy-kamikaze-color: #ffffff; --boss-color: #ff00ff;
            --enemy-sentinel-color: #c0c0c0; --enemy-bulwark-color: #708090; --enemy-barrier-color: #4682b4;
            --enemy-splitter-color: #ff6600; --enemy-summoner-color: #b300ff;
            --enemy-bullet-color: #ff80ff;
            --powerup-p-color: #4dff4d; --powerup-b-color: #4da6ff; --powerup-c-color: #cc66ff; --powerup-s-color: #a9d4ff;
            --hud-color: #ffffff; --gauge-color: #00ffff; --gauge-bg-color: #33334d; --button-bg: rgba(255, 255, 255, 0.1); --button-border: rgba(255, 255, 255, 0.5); --shard-color: #a9d4ff;
            --rarity-default: #cccccc; --rarity-normal: #ffffff; --rarity-rare: #00aaff; --rarity-legendary: #ff8000; --rarity-mythic: #ff40ff;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background-color: var(--bg-color); color: var(--hud-color); font-family: 'Press Start 2P',-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif; -webkit-tap-highlight-color: transparent; }
        #game-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; position: relative; }
        canvas#game-canvas { background-color: #000; border: 1px solid var(--button-border); touch-action: none; position: relative; z-index: 5; }
        .hud, .screen-overlay { text-shadow: 2px 2px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000; }
        .hud { position: absolute; width: 100%; padding: 15px 20px; font-size: 1em; line-height: 1.4; pointer-events: none; z-index: 15; }
        #top-hud { top: 0; display: flex; justify-content: space-between; align-items: flex-start; }
        #bottom-hud { bottom: 0; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #chrono-gauge-container { width: 80%; height: 15px; background-color: var(--gauge-bg-color); border: 2px solid var(--button-border); border-radius: 10px; overflow: hidden; }
        #chrono-gauge-bar { width: 0%; height: 100%; background-color: var(--gauge-color); transition: width 0.1s linear; }
        #bomb-info, #life-info { font-size: 1.2em; }
        .mobile-control { position: absolute; bottom: 30px; width: 70px; height: 70px; background-color: var(--button-bg); border: 2px solid var(--button-border); border-radius: 50%; color: white; display: none; justify-content: center; align-items: center; font-size: 0.8em; user-select: none; z-index: 10; }
        #chrono-break-button { left: 30px; }
        #bomb-button { right: 30px; }
        .mobile-control.active { background-color: rgba(0, 255, 255, 0.5); }
        .screen-overlay { position: absolute; top:0; left:0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 20; cursor: default; padding: 10px; background: radial-gradient(ellipse at center, rgba(13, 13, 26, 0.95) 0%, rgba(13, 13, 26, 1) 100%); gap: 10px; justify-content: flex-start; padding-top: 3%; }
        .screen-overlay h1 { font-size: 2.2em; line-height: 1.2; margin-bottom: 10px; text-shadow: 3px 3px 0px var(--player-color), -3px -3px 0px var(--player-color), 3px -3px 0px var(--player-color), -3px 3px 0px var(--player-color); }
        .screen-overlay p { font-size: 1em; margin: 5px 0; line-height: 1.5; }
        .screen-overlay button { padding: 10px 20px; font-size: 1em; font-weight: bold; color: var(--bg-color); background-color: var(--player-color); border: none; border-radius: 10px; cursor: pointer; box-shadow: 0 0 15px var(--player-color); transition: all 0.1s; margin-top: 10px; font-family: 'Press Start 2P', cursive; }
        .screen-overlay button:hover:not(:disabled) { transform: scale(1.05); filter: brightness(1.2); }
        .screen-overlay button:active { transform: scale(0.95); }
        .screen-overlay button:disabled { background-color: #555; color: #888; cursor: not-allowed; box-shadow: none; }
        #main-menu-screen { display: flex; justify-content: center; gap: 15px; }
        #game-over-screen, #hangar-screen, #shop-screen, #profile-screen { display: none; }
        #game-over-screen h1 { text-shadow: 2px 2px 0px #ff0000, -2px -2px 0px #ff0000, 2px -2px 0px #ff0000, -2px 2px 0px #ff0000; }
        .shard-display { color: var(--shard-color); font-size: 1.2em; font-weight: bold; background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px; border: 1px solid var(--button-border); }
        #main-title-display { color: var(--rarity-legendary); font-size: 0.8em; margin-bottom: 10px; }
        #shards-earned.animate { animation: pop-in 0.5s ease-out; }
        @keyframes pop-in { 0% { transform: scale(0.5); opacity: 0; } 80% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(1); } }
        @keyframes fade-out { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(1.2); } }
        .main-menu-buttons { display: flex; flex-direction: column; gap: 15px; width: 80%; max-width: 400px; }
        .main-menu-buttons button { padding: 15px 20px; font-size: 1.2em; width: 100%; }
        /* Hangar & Profile Content */
        .content-panel { display: flex; width: 100%; max-width: 600px; gap: 10px; flex-grow: 1; min-height: 0; }
        .left-panel { display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding-right: 5px; flex-basis: 45%; }
        .right-panel { flex-basis: 55%; display: flex; flex-direction: column; gap: 10px; background: rgba(0,0,0,0.2); border: 1px solid var(--button-border); border-radius: 10px; padding: 10px; overflow-y: auto; }
        .char-portrait { width: 100%; height: 80px; border: 3px solid var(--button-border); border-radius: 10px; cursor: pointer; display: flex; justify-content: flex-start; align-items: center; transition: all 0.2s; padding: 10px; background: rgba(0,0,0,0.2); position: relative; gap: 10px; }
        .char-portrait.selected { border-color: var(--player-color); background: rgba(0, 255, 255, 0.1); box-shadow: 0 0 10px var(--player-color); }
        .char-portrait.locked { background-color: rgba(0,0,0,0.7); cursor: pointer; }
        .char-portrait.locked::after { content: 'üîí'; position: absolute; top: 5px; right: 10px; font-size: 1.2em; }
        .char-portrait-info { display: flex; flex-direction: column; text-align: left; }
        .char-icon { font-size: 2em; }
        .char-name { font-weight: bold; font-size: 0.8em; }
        .char-highscore { font-size: 0.6em; color: var(--enemy-color-2); }
        #selected-char-details { text-align: left; font-size: 0.7em; line-height: 1.3; border-bottom: 1px solid var(--button-border); padding-bottom: 8px; }
        #selected-char-details h3 { font-size: 1.2em; text-align: center; margin-bottom: 5px; }
        #selected-char-details p { margin-left: 5px; }
        #skin-selection-container { display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; margin-top: 5px; }
        .skin-swatch { width: 25px; height: 25px; border: 2px solid var(--button-border); border-radius: 5px; cursor: pointer; transition: all 0.2s; }
        .skin-swatch.selected { transform: scale(1.2); box-shadow: 0 0 10px #fff; }
        .skin-swatch.locked { background: repeating-linear-gradient(45deg, #333, #333 4px, #444 4px, #444 8px); cursor: not-allowed; }
        .skin-swatch.rarity-default { border-color: var(--rarity-default); } .skin-swatch.rarity-normal { border-color: var(--rarity-normal); } .skin-swatch.rarity-rare { border-color: var(--rarity-rare); } .skin-swatch.rarity-legendary { border-color: var(--rarity-legendary); } .skin-swatch.rarity-mythic { border-color: var(--rarity-mythic); }
        #upgrade-section { display: flex; flex-direction: column; gap: 8px; font-size: 0.7em; margin-top: 10px; }
        .upgrade-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .upgrade-row button { padding: 5px 8px; font-size: 0.9em; margin-top: 0; }
        .bottom-panel-buttons { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; max-width: 600px; margin-top: auto; padding-top: 10px; }
        /* Shop Screen */
        #shop-content { display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 450px; align-items: center; overflow-y: auto; flex-grow: 1; padding: 5px;}
        .shop-item { background: rgba(0,0,0,0.2); border: 1px solid var(--button-border); border-radius: 10px; padding: 15px; width: 100%; display: flex; align-items: center; gap: 15px; flex-shrink: 0; }
        .skin-preview-canvas { background-color: #000; border-radius: 5px; }
        .shop-item-info { flex-grow: 1; text-align: left; }
        .shop-item-name { font-size: 0.9em; }
        .shop-item-rarity-normal { color: var(--rarity-normal); } .shop-item-rarity-rare { color: var(--rarity-rare); } .shop-item-rarity-legendary { color: var(--rarity-legendary); }
        .shop-item-price { font-size: 0.8em; color: var(--shard-color); }
        .shop-item button { font-size: 0.8em; padding: 8px 12px; margin: 0; }
        /* Profile Screen */
        .tab-buttons { display: flex; gap: 10px; margin-bottom: 10px; }
        .tab-buttons button { margin-top: 0; }
        .tab-buttons button.active { background-color: var(--player-color); color: var(--bg-color); }
        .tab-content { width: 100%; display: none; flex-grow: 1; overflow-y: auto; }
        .tab-content.active { display: block; }
        .mission-item, .title-item { text-align: left; background: rgba(0,0,0,0.2); border: 1px solid var(--button-border); border-radius: 10px; padding: 10px; margin-bottom: 10px; font-size: 0.8em; }
        .mission-desc { margin-bottom: 5px; }
        .mission-progress-bar { width: 100%; height: 10px; background: var(--gauge-bg-color); border-radius: 5px; overflow: hidden; margin-bottom: 5px; }
        .mission-progress-fill { height: 100%; background: var(--rarity-rare); }
        .mission-reward { display: flex; justify-content: space-between; align-items: center; }
        .mission-reward button { padding: 5px 10px; font-size: 0.9em; margin: 0; }
        .title-item { cursor: pointer; }
        .title-item.locked { color: #888; cursor: default; }
        .title-item.selected { border-color: var(--player-color); box-shadow: 0 0 10px var(--player-color); }
        .title-item .title-desc { font-size: 0.8em; color: #aaa; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="main-menu-screen" class="screen-overlay">
            <h1>CHRONO BREAK</h1>
            <p id="main-title-display"></p>
            <p class="shard-display">üíé 0</p>
            <div class="main-menu-buttons">
                <button id="start-game-button">START</button>
                <button id="hangar-button">Í≤©ÎÇ©Í≥†</button>
                <button id="shop-button">ÏÉÅÏ†ê</button>
                <button id="profile-button">ÌîÑÎ°úÌïÑ</button>
                <button id="control-toggle-button">Ïª®Ìä∏Î°§: ÌÇ§Î≥¥Îìú</button>
            </div>
        </div>
        <div id="hangar-screen" class="screen-overlay">
            <h1>Í≤©ÎÇ©Í≥†</h1>
            <p class="shard-display">üíé 0</p>
            <div class="content-panel">
                <div id="character-list-panel" class="left-panel"></div>
                <div id="right-panel" class="right-panel">
                    <div id="selected-char-details"></div>
                    <div id="skin-selection-container"></div>
                    <div id="upgrade-section"></div>
                </div>
            </div>
            <div class="bottom-panel-buttons">
                <button id="char-gacha-button">Ï∫êÎ¶≠ÌÑ∞ ÎΩëÍ∏∞ (üíé1500)</button>
                <button id="back-to-menu-from-hangar-button">Îí§Î°úÍ∞ÄÍ∏∞</button>
            </div>
        </div>
        <div id="shop-screen" class="screen-overlay">
            <h1>Ïò§ÎäòÏùò ÏÉÅÏ†ê</h1>
            <p class="shard-display">üíé 0</p>
            <div id="shop-content"></div>
            <div class="bottom-panel-buttons">
                 <button id="shop-refresh-button">ÏÉàÎ°úÍ≥†Ïπ® (üíé150)</button>
                <button id="back-to-menu-from-shop-button">Îí§Î°úÍ∞ÄÍ∏∞</button>
            </div>
        </div>
        <div id="profile-screen" class="screen-overlay">
            <h1>ÌîÑÎ°úÌïÑ</h1>
            <div class="tab-buttons">
                <button id="missions-tab-button" class="active">ÎØ∏ÏÖò</button>
                <button id="titles-tab-button">Ïπ≠Ìò∏</button>
            </div>
            <div id="missions-tab" class="tab-content active"></div>
            <div id="titles-tab" class="tab-content"></div>
            <div class="bottom-panel-buttons">
                <button id="back-to-menu-from-profile-button">Îí§Î°úÍ∞ÄÍ∏∞</button>
            </div>
        </div>
        <div id="top-hud" class="hud">
            <div><span id="score">SCORE: 0</span><br><span id="high-score">HIGH: 0</span></div>
            <div style="text-align: right;"><span id="life-info"></span><br><span id="bomb-info"></span></div>
        </div>
        <div id="bottom-hud" class="hud">
            <div id="chrono-gauge-container"><div id="chrono-gauge-bar"></div></div>
        </div>
        <div id="chrono-break-button" class="mobile-control">BREAK</div>
        <div id="bomb-button" class="mobile-control">BOMB</div>
        <div id="game-over-screen" class="screen-overlay">
            <h1>GAME OVER</h1>
            <p id="final-score"></p>
            <p id="shards-earned"></p>
            <button id="return-to-menu-button">MENU</button>
        </div>
    </div>

    <script>
    // --- 1. Ï†ÑÏó≠ Î≥ÄÏàò Î∞è ÏÉÅÏàò Ï¥àÍ∏∞Ìôî ---
    const gameContainer = document.getElementById('game-container');
    const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
    const mainMenuScreen = document.getElementById('main-menu-screen'), gameOverScreen = document.getElementById('game-over-screen');
    const hangarScreen = document.getElementById('hangar-screen'), shopScreen = document.getElementById('shop-screen'), profileScreen = document.getElementById('profile-screen');
    const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('high-score'), lifeInfoEl = document.getElementById('life-info'), bombInfoEl = document.getElementById('bomb-info'), chronoGaugeBarEl = document.getElementById('chrono-gauge-bar');
    const shardDisplays = document.querySelectorAll('.shard-display'), mainTitleDisplay = document.getElementById('main-title-display');
    const charListPanel = document.getElementById('character-list-panel'), upgradeSection = document.getElementById('upgrade-section'), skinSelectionContainer = document.getElementById('skin-selection-container'), selectedCharDetailsEl = document.getElementById('selected-char-details');
    const charGachaButton = document.getElementById('char-gacha-button'), startGameButton = document.getElementById('start-game-button'), returnToMenuButton = document.getElementById('return-to-menu-button'), controlToggleButton = document.getElementById('control-toggle-button');
    const hangarButton = document.getElementById('hangar-button'), shopButton = document.getElementById('shop-button'), profileButton = document.getElementById('profile-button'), shopRefreshButton = document.getElementById('shop-refresh-button');
    const backToMenuFromHangarBtn = document.getElementById('back-to-menu-from-hangar-button'), backToMenuFromShopBtn = document.getElementById('back-to-menu-from-shop-button'), backToMenuFromProfileBtn = document.getElementById('back-to-menu-from-profile-button');
    const shopContentEl = document.getElementById('shop-content');
    const missionsTab = document.getElementById('missions-tab'), titlesTab = document.getElementById('titles-tab');
    const missionsTabBtn = document.getElementById('missions-tab-button'), titlesTabBtn = document.getElementById('titles-tab-button');
    const finalScoreEl = document.getElementById('final-score'), shardsEarnedEl = document.getElementById('shards-earned');
    const mobileChronoButton = document.getElementById('chrono-break-button'), mobileBombButton = document.getElementById('bomb-button');
    
    let gameState = 'mainMenu', controlMode = 'keyboard', gameSpeed = 1, lastTime = 0, animationFrameId = null;
    let score = 0, highScore = 0, scoreMultiplier = 1, wave = 0, waveTimer = 0;
    let player, enemies = [], bullets = [], particles = [], powerUps = [], backgroundStars = [];
    let turrets = [], allies = [];
    let screenShake = 0, lowHealthPulse = 0;
    const colors = {};
    let chronoShards = 0, waveClearBonus = 0, bossKillBonus = 0;
    let selectedCharacterId = 'stinger';
    let dailyDeals = { date: null, items: [] };
    let playerStats = {};

    const SKIN_RARITY = { default: 0, normal: 1, rare: 2, legendary: 3, mythic: 4 };
    const SKIN_PRICES = { normal: 2000, rare: 5000, legendary: 20000 };
    const SKIN_GEOMETRY = {
        default: [{x:0,y:-1},{x:-0.66,y:0.5},{x:0.66,y:0.5}],
        stinger: [{x:0,y:-1.2},{x:-0.3,y:0.4},{x:-0.8,y:0.2},{x:0.8,y:0.2},{x:0.3,y:0.4}], stinger_L: [{x:0,y:-1.3},{x:-0.2,y:-0.5},{x:-1,y:0.7},{x:0,y:0},{x:1,y:0.7},{x:0.2,y:-0.5}], stinger_M: [{x:0,y:-1.4},{x:-0.4,y:0.8},{x:0,y:0.4},{x:0.4,y:0.8},{x:-1.2,y:-0.2},{x:1.2,y:-0.2}],
        guardian: [{x:0,y:-1},{x:-0.9,y:-0.2},{x:-0.7,y:0.8},{x:0.7,y:0.8},{x:0.9,y:-0.2}], guardian_L: [{x:0,y:-1},{x:-1,y:0},{x:-1,y:0.8},{x:1,y:0.8},{x:1,y:0}], guardian_M: [{x:-1,y:-1},{x:1,y:-1},{x:1,y:0.5},{x:0,y:1},{x:-1,y:0.5}],
        spectre: [{x:0,y:-1.1}, {x:-0.4,y:-0.5}, {x:-0.8,y:0.6}, {x:0,y:0.2}, {x:0.8,y:0.6}, {x:0.4,y:-0.5}], spectre_L: [{x:0,y:-1.2}, {x:-0.9,y:0.8}, {x:0,y:-0.4}, {x:0.9,y:0.8}], spectre_M: [{x:0,y:-1.3}, {x:-0.5,y:-0.8}, {x:-1.2,y:0.9}, {x:0,y:0.5}, {x:1.2,y:0.9}, {x:0.5,y:-0.8}],
        pulse: [{x:0,y:-1}, {x:-0.95,y:-0.3}, {x:-0.58,y:0.8}, {x:0.58,y:0.8}, {x:0.95,y:-0.3}], pulse_L: [{x:0,y:-1}, {x:-1,y:0}, {x:0,y:1}, {x:1,y:0}], pulse_M: [{x:0,y:-1.2}, {x:-1,y:-0.6}, {x:-1,y:0.6}, {x:0,y:1.2}, {x:1,y:0.6}, {x:1,y:-0.6}],
        blade: [{x:0,y:-1.1},{x:-1,y:0.6},{x:0,y:0.3},{x:1,y:0.6}], blade_L: [{x:0,y:-1.2}, {x:-0.4,y:0.9}, {x:0,y:-0.5}, {x:0.4,y:0.9}], blade_M: [{x:0,y:-1.3}, {x:-1.2,y:1}, {x:0,y:0.4}, {x:1.2,y:1}],
        nova: [{x:0,y:-1}, {x:-0.8,y:0}, {x:-0.3,y:0.8}, {x:0.3,y:0.8}, {x:0.8,y:0}], nova_L: [{x:0,y:-1.2}, {x:-0.5,y:-0.5}, {x:-1,y:0.5}, {x:0,y:0.8}, {x:1,y:0.5}, {x:0.5,y:-0.5}], nova_M: [{x:0,y:-1.3}, {x:-1,y:-0.8}, {x:-0.5,y:0.9}, {x:0.5,y:0.9}, {x:1,y:-0.8}],
        rift: [{x:0,y:-1.1}, {x:-0.6,y:-0.6}, {x:-0.9,y:0.7}, {x:0,y:0.2}, {x:0.9,y:0.7}, {x:0.6,y:-0.6}], rift_L: [{x:0,y:-1.2}, {x:-1.1,y:0}, {x:0,y:1.2}, {x:1.1,y:0}], rift_M: [{x:0,y:-1.3}, {x:-0.8,y:0}, {x:0,y:-0.5}, {x:0.8,y:0}, {x:-0.4,y:1}, {x:0.4,y:1}],
        aegis: [{x:-0.8,y:-0.8}, {x:0.8,y:-0.8}, {x:1,y:0.6}, {x:0,y:1}, {x:-1,y:0.6}], aegis_L: [{x:-1,y:-1}, {x:1,y:-1}, {x:1.2,y:0.7}, {x:0,y:1.2}, {x:-1.2,y:0.7}], aegis_M: [{x:-1.2,y:-1.2}, {x:1.2,y:-1.2}, {x:1.2,y:1.2}, {x:-1.2,y:1.2}],
        berserker: [{x:0,y:-1.2}, {x:-0.3,y:-0.3}, {x:-1,y:-0.5}, {x:-0.5,y:0.8}, {x:0.5,y:0.8}, {x:1,y:-0.5}, {x:0.3,y:-0.3}], berserker_L: [{x:0,y:-1.3}, {x:-1.2,y:-0.5}, {x:-0.6,y:0.9}, {x:0.6,y:0.9}, {x:1.2,y:-0.5}], berserker_M: [{x:0,y:-1.4}, {x:-1,y:-1}, {x:-1.3,y:0}, {x:-0.5,y:1}, {x:0.5,y:1}, {x:1.3,y:0}, {x:1,y:-1}],
        tempest: [{x:0,y:-1}, {x:-1,y:0.2}, {x:-0.5,y:0.8}, {x:0.5,y:0.8}, {x:1,y:0.2}], tempest_L: [{x:0,y:-1.1}, {x:-0.8,y:-0.8}, {x:-1.1,y:0}, {x:-0.8,y:0.8}, {x:0,y:1.1}, {x:0.8,y:0.8}, {x:1.1,y:0}, {x:0.8,y:-0.8}], tempest_M: [{x:0,y:-1.2}, {x:-0.5,y:-0.5}, {x:-1.2,y:-0.5}, {x:-0.7,y:0.8}, {x:0.7,y:0.8}, {x:1.2,y:-0.5}, {x:0.5,y:-0.5}],
        phase: [{x:-0.5,y:-1},{x:0.5,y:-1},{x:1,y:0},{x:0.5,y:1},{x:-0.5,y:1},{x:-1,y:0}], phase_L: [{x:-0.8,y:-1.1}, {x:0.8,y:-1.1}, {x:1.2,y:0}, {x:0,y:1.1}, {x:-1.2,y:0}], phase_M: [{x:0,y:-1.2}, {x:-1,y:-0.2}, {x:-0.6,y:1.2}, {x:0.6,y:1.2}, {x:1,y:-0.2}],
        echo: [{x:0,y:-1},{x:-0.9,y:0},{x:-0.5,y:0.8},{x:0.5,y:0.8},{x:0.9,y:0}], echo_L: [{x:0,y:-1.1}, {x:-1,y:-0.5}, {x:-0.8,y:0.9}, {x:0.8,y:0.9}, {x:1,y:-0.5}], echo_M: [{x:0,y:-1.2}, {x:-0.6,y:-0.6}, {x:0.6,y:-0.6}, {x:-1.2,y:0.4}, {x:1.2,y:0.4}, {x:-0.6,y:1}, {x:0.6,y:1}],
        comet: [{x:0,y:-1.2},{x:-0.5,y:0.6},{x:0,y:0.2},{x:0.5,y:0.6}], comet_L: [{x:0,y:-1.3}, {x:-0.8,y:0.8}, {x:0,y:-0.2}, {x:0.8,y:0.8}], comet_M: [{x:0,y:-1.4}, {x:-0.4,y:-0.2}, {x:-1,y:0.9}, {x:0,y:0.5}, {x:1,y:0.9}, {x:0.4,y:-0.2}],
        arbiter: [{x:0,y:-1}, {x:-1,y:0}, {x:-0.7,y:0.8}, {x:0.7,y:0.8}, {x:1,y:0}], arbiter_L: [{x:0,y:-1.1}, {x:-1.2,y:-0.2}, {x:-0.8,y:0.9}, {x:0.8,y:0.9}, {x:1.2,y:-0.2}], arbiter_M: [{x:0,y:-1.2}, {x:-1.2,y:-0.4}, {x:-1,y:0.9}, {x:0,y:0.6}, {x:1,y:0.9}, {x:1.2,y:-0.4}],
        sentry: [{x:-0.8,y:-0.8}, {x:0.8,y:-0.8}, {x:0.8,y:0.8}, {x:-0.8,y:0.8}], sentry_L: [{x:-1,y:-1}, {x:1,y:-1}, {x:1,y:1}, {x:-1,y:1}, {x:-1,y:-1}, {x:-0.6,y:-0.6}, {x:0.6,y:-0.6}, {x:0.6,y:0.6}, {x:-0.6,y:0.6}, {x:-0.6,y:-0.6}], sentry_M: [{x:-1.2,y:-1.2}, {x:1.2,y:-1.2}, {x:1.2,y:1.2}, {x:-1.2,y:1.2}, {x:-1.2,y:-1.2}, {x:0,y:-0.8}, {x:0.8,y:0}, {x:0,y:0.8}, {x:-0.8,y:0}, {x:0,y:-0.8}],
        conjuror: [{x:0,y:-1}, {x:-0.5,y:-0.5}, {x:-0.2,y:0.8}, {x:0.2,y:0.8}, {x:0.5,y:-0.5}], conjuror_L: [{x:0,y:-1.1}, {x:-0.8,y:-0.4}, {x:-0.8,y:0.8}, {x:0,y:0.4}, {x:0.8,y:0.8}, {x:0.8,y:-0.4}], conjuror_M: [{x:0,y:-1.2}, {x:-0.5,y:-0.9}, {x:-1.2,y:0.2}, {x:-0.5,y:1}, {x:0.5,y:1}, {x:1.2,y:0.2}, {x:0.5,y:-0.9}],
        vector: [{x:0,y:-1.1}, {x:-0.3,y:-0.3}, {x:-0.8,y:0.3}, {x:-0.3,y:0.8}, {x:0.3,y:0.8}, {x:0.8,y:0.3}, {x:0.3,y:-0.3}], vector_L: [{x:0,y:-1.2}, {x:-0.5,y:-0.5}, {x:-1,y:0.5}, {x:-0.5,y:1}, {x:0.5,y:1}, {x:1,y:0.5}, {x:0.5,y:-0.5}], vector_M: [{x:0,y:-1.3}, {x:-0.7,y:-0.7}, {x:-1.2,y:0.7}, {x:-0.7,y:1.2}, {x:0.7,y:1.2}, {x:1.2,y:0.7}, {x:0.7,y:-0.7}],
        nebula: [{x:0,y:-0.8}, {x:-0.9,y:-0.3}, {x:-0.7,y:0.6}, {x:0,y:0.9}, {x:0.7,y:0.6}, {x:0.9,y:-0.3}], nebula_L: [{x:0,y:-1}, {x:-1.1,y:-0.4}, {x:-0.8,y:0.8}, {x:0,y:1.1}, {x:0.8,y:0.8}, {x:1.1,y:-0.4}], nebula_M: [{x:0,y:-1.2}, {x:-1.3,y:-0.5}, {x:-1,y:1}, {x:0,y:1.3}, {x:1,y:1}, {x:1.3,y:-0.5}],
        vortex: [{x:0,y:-1}, {x:-0.7,y:-0.7}, {x:-1,y:0}, {x:-0.7,y:0.7}, {x:0,y:1}, {x:0.7,y:0.7}, {x:1,y:0}, {x:0.7,y:-0.7}], vortex_L: [{x:0,y:-1.1}, {x:-0.8,y:-0.8}, {x:-1.1,y:0}, {x:-0.8,y:0.8}, {x:0,y:1.1}, {x:0.8,y:0.8}, {x:1.1,y:0}, {x:0.8,y:-0.8}], vortex_M: [{x:0,y:-1.3}, {x:-0.9,y:-0.9}, {x:-1.3,y:0}, {x:-0.9,y:0.9}, {x:0,y:1.3}, {x:0.9,y:0.9}, {x:1.3,y:0}, {x:0.9,y:-0.9}, {x:0,y:0}],
        prism: [{x:0,y:-1.2}, {x:-0.6,y:-0.4}, {x:-0.8,y:0.8}, {x:0.8,y:0.8}, {x:0.6,y:-0.4}], prism_L: [{x:0,y:-1.3}, {x:-0.7,y:-0.5}, {x:-1,y:0.9}, {x:1,y:0.9}, {x:0.7,y:-0.5}], prism_M: [{x:0,y:-1.4}, {x:-0.8,y:-0.6}, {x:-1.2,y:1}, {x:1.2,y:1}, {x:0.8,y:-0.6}, {x:0,y:-0.2}],
        chaos: [{x:0,y:-1}, {x:-0.5,y:-0.5}, {x:-0.8,y:0.2}, {x:-0.3,y:0.9}, {x:0.3,y:0.9}, {x:0.8,y:0.2}, {x:0.5,y:-0.5}], chaos_L: [{x:0,y:-1.1}, {x:-0.6,y:-0.6}, {x:-0.9,y:0.3}, {x:-0.4,y:1}, {x:0.4,y:1}, {x:0.9,y:0.3}, {x:0.6,y:-0.6}], chaos_M: [{x:0,y:-1.2}, {x:-0.7,y:-0.7}, {x:-1,y:0.4}, {x:-0.5,y:1.1}, {x:0.5,y:1.1}, {x:1,y:0.4}, {x:0.7,y:-0.7}, {x:0,y:0}]
    };

    const SKIN_DATA = {};
    const ALL_CHAR_IDS = ['stinger', 'guardian', 'spectre', 'pulse', 'blade', 'nova', 'rift', 'aegis', 'berserker', 'tempest', 'phase', 'echo', 'comet', 'arbiter', 'sentry', 'conjuror', 'vector', 'nebula', 'vortex', 'prism', 'chaos'];
    
    ALL_CHAR_IDS.forEach(id => {
        const geom_L = SKIN_GEOMETRY[id+'_L'] ? id+'_L' : id;
        const geom_M = SKIN_GEOMETRY[id+'_M'] ? id+'_M' : geom_L;
        SKIN_DATA[id] = {
            default:   { name: 'Í∏∞Î≥∏', shipColor: '#cccccc', attackColor: '#ffffff', accentColor: '#ffffff', geometry: id, killEffect: 'default', hasTrail: false, hasSkillEffect: false },
            normal:    { name: 'Ïª§Ïä§ÌÖÄ', shipColor: '#9acd32', attackColor: '#ffffff', accentColor: '#ffffff', geometry: id, killEffect: 'default', hasTrail: false, hasSkillEffect: false },
            rare:      { name: 'ÌÅ¨Î¶ºÏä®', shipColor: '#dc143c', attackColor: '#ff6347', accentColor: '#ffffff', geometry: id, killEffect: 'default', hasTrail: false, hasSkillEffect: false },
            legendary: { name: 'Î†àÏ†ÑÎçîÎ¶¨', shipColor: '#ff8000', attackColor: '#ff8000', accentColor: '#ffff00', geometry: geom_L, killEffect: 'firework', hasTrail: false, hasSkillEffect: false },
            mythic:    { name: 'Ïã†Ìôî', shipColor: '#ff40ff', attackColor: '#ff40ff', accentColor: '#ffffff', geometry: geom_M, killEffect: 'firework', hasTrail: true, hasSkillEffect: true },
        };
    });
    // Unique Legendary/Mythic names and colors
    SKIN_DATA.stinger.legendary = { name: 'Ïù∏ÌéòÎ•¥ÎÖ∏', shipColor: '#ff4500', attackColor: '#ff8c00', accentColor: '#ffff00', geometry: 'stinger_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.stinger.mythic = { name: 'Î≥¥Ïù¥ÎìúÎ¶¨Ìçº', shipColor: '#9400d3', attackColor: '#ee82ee', accentColor: '#00ffff', geometry: 'stinger_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.guardian.legendary = { name: 'Í≥®Î¶¨Ïïó', shipColor: '#a0522d', attackColor: '#cd853f', accentColor: '#f4a460', geometry: 'guardian_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.guardian.mythic = { name: 'ÏÑ±Ï±Ñ', shipColor: '#dcdcdc', attackColor: '#ffffff', accentColor: '#ffd700', geometry: 'guardian_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.spectre.legendary = { name: 'Ìå¨ÌÖÄ', shipColor: '#e6e6fa', attackColor: '#dda0dd', accentColor: '#ffffff', geometry: 'spectre_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.spectre.mythic = { name: 'Î∞¥Ïãú', shipColor: '#00ced1', attackColor: '#48d1cc', accentColor: '#f0ffff', geometry: 'spectre_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.pulse.legendary = { name: 'ÎùºÏù¥Ìä∏Îãù Î°úÎìú', shipColor: '#ffd700', attackColor: '#ffff00', accentColor: '#ffffff', geometry: 'pulse_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.blade.legendary = { name: 'Î¨¥ÎùºÎßàÏÇ¨', shipColor: '#b22222', attackColor: '#ff3333', accentColor: '#ffffff', geometry: 'blade_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.blade.mythic = { name: 'ÏóëÏä§ÏπºÎ¶¨Î≤Ñ', shipColor: '#ffd700', attackColor: '#fffacd', accentColor: '#ffffff', geometry: 'blade_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.nova.legendary = { name: 'ÌÉúÏñë ÏûëÎ†¨', shipColor: '#ff8c00', attackColor: '#ffa500', accentColor: '#ff4500', geometry: 'nova_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.nova.mythic = { name: 'Ï¥àÏã†ÏÑ±', shipColor: '#4169e1', attackColor: '#87cefa', accentColor: '#ffffff', geometry: 'nova_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.rift.legendary = { name: 'Ï∞®Ïõê Ï†àÎã®Í∏∞', shipColor: '#8a2be2', attackColor: '#9932cc', accentColor: '#da70d6', geometry: 'rift_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.aegis.legendary = { name: 'ÏÑ±Í∏∞ÏÇ¨', shipColor: '#f5deb3', attackColor: '#d2b48c', accentColor: '#ffd700', geometry: 'aegis_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.berserker.legendary = { name: 'ÌôîÏÇ∞', shipColor: '#8b0000', attackColor: '#ff4500', accentColor: '#ff0000', geometry: 'berserker_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.tempest.legendary = { name: 'ÌóàÎ¶¨ÏºÄÏù∏', shipColor: '#4682b4', attackColor: '#87ceeb', accentColor: '#ffffff', geometry: 'tempest_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.phase.legendary = { name: 'ÎØ∏ÎùºÏßÄ', shipColor: '#fafad2', attackColor: '#eee8aa', accentColor: '#ffd700', geometry: 'phase_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.echo.legendary = { name: 'ÌÅ¨Î°úÎÖ∏ ÏõåÏ≤ò', shipColor: '#2f4f4f', attackColor: '#008080', accentColor: '#00ffff', geometry: 'echo_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.comet.legendary = { name: 'Ïú†ÏÑ±', shipColor: '#00bfff', attackColor: '#1e90ff', accentColor: '#add8e6', geometry: 'comet_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.arbiter.legendary = { name: 'ÏßëÌñâÏûê', shipColor: '#708090', attackColor: '#778899', accentColor: '#b0c4de', geometry: 'arbiter_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.sentry.legendary = { name: 'ÏöîÏÉà', shipColor: '#696969', attackColor: '#a9a9a9', accentColor: '#d3d3d3', geometry: 'sentry_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.sentry.mythic = { name: 'ÏµúÏ¢Ö Î∞©Ïñ¥ÏÑ†', shipColor: '#f0e68c', attackColor: '#ffd700', accentColor: '#ffffff', geometry: 'sentry_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.conjuror.legendary = { name: 'ÎåÄÎßàÎ≤ïÏÇ¨', shipColor: '#483d8b', attackColor: '#9370db', accentColor: '#e6e6fa', geometry: 'conjuror_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.vector.legendary = { name: 'ÌÉÑÎèÑÌïôÏûê', shipColor: '#ff6347', attackColor: '#ffa500', accentColor: '#ffff00', geometry: 'vector_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.vector.mythic = { name: 'Í∂§ÎèÑ ÎßàÏä§ÌÑ∞', shipColor: '#9400d3', attackColor: '#ba55d3', accentColor: '#ffffff', geometry: 'vector_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.nebula.legendary = { name: 'ÏÑ±Ïö¥ Ï†úÏôï', shipColor: '#4b0082', attackColor: '#8a2be2', accentColor: '#dda0dd', geometry: 'nebula_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.nebula.mythic = { name: 'Ïö∞Ï£ºÏùò Ïã¨Ïó∞', shipColor: '#191970', attackColor: '#6495ed', accentColor: '#87ceeb', geometry: 'nebula_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.vortex.legendary = { name: 'ÌÉúÌíçÏùò Îàà', shipColor: '#008b8b', attackColor: '#00ced1', accentColor: '#e0ffff', geometry: 'vortex_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.vortex.mythic = { name: 'Ï†àÎåÄ ÏÜåÏö©ÎèåÏù¥', shipColor: '#2f4f4f', attackColor: '#40e0d0', accentColor: '#ffffff', geometry: 'vortex_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.prism.legendary = { name: 'Î¨¥ÏßÄÍ∞ú Î∂ÑÏÇ∞', shipColor: '#9370db', attackColor: '#ff69b4', accentColor: '#ffff00', geometry: 'prism_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.prism.mythic = { name: 'Ïä§ÌéôÌä∏Îüº ÎßàÏä§ÌÑ∞', shipColor: '#4b0082', attackColor: '#ff1493', accentColor: '#ffffff', geometry: 'prism_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };
    SKIN_DATA.chaos.legendary = { name: 'ÌòºÎèàÏùò ÌôîÏã†', shipColor: '#8b0000', attackColor: '#ff4500', accentColor: '#ffd700', geometry: 'chaos_L', killEffect: 'firework', hasTrail: false, hasSkillEffect: false };
    SKIN_DATA.chaos.mythic = { name: 'ÏóîÌä∏Î°úÌîº Ï†úÏñ¥Ïûê', shipColor: '#2f4f4f', attackColor: '#ff6347', accentColor: '#ffffff', geometry: 'chaos_M', killEffect: 'firework', hasTrail: true, hasSkillEffect: true };

    let characters = {
        stinger:   { name: 'Ïä§ÌåÖÏñ¥', icon: '‚ñ∂', unlocked: true,  attackDesc: 'Ï†ÑÎ∞© ÏßëÏ§ëÌòï ÌëúÏ§Ä ÏÉ∑', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        guardian:  { name: 'Í∞ÄÎîîÏñ∏', icon: '‚ùñ', unlocked: false, attackDesc: 'Í¥ëÏó≠ Î∂ÄÏ±ÑÍº¥ ÏÉ∑', specialDesc: 'ÏãúÏûë Ìè≠ÌÉÑ +1' },
        spectre:   { name: 'Ïä§ÌéôÌÑ∞', icon: '‚¨ü', unlocked: false, attackDesc: 'Ïú†ÎèÑÌÉÑ Î∞úÏÇ¨', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        pulse:     { name: 'ÌéÑÏä§',   icon: '‚óé', unlocked: false, attackDesc: 'Í∑ºÏ†ë Î∞©ÏÇ¨Ìòï ÌååÎèô', specialDesc: 'Ï†Å Ï≤òÏπò Ïãú Í≤åÏù¥ÏßÄ ÌöåÎ≥µ' },
        blade:     { name: 'Î∏îÎ†àÏù¥Îìú', icon: '‚ñ≤', unlocked: false, attackDesc: 'Í¥ÄÌÜµÌòï Î∏îÎ†àÏù¥Îìú', specialDesc: 'ÏÉùÎ™Ö 1, Ï†êÏàò 1.5Î∞∞' },
        nova:      { name: 'ÎÖ∏Î∞î',   icon: '‚úß', unlocked: false, attackDesc: 'Ï∞®ÏßÄ Î†àÏù¥Ï†Ä', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        rift:      { name: 'Î¶¨ÌîÑÌä∏', icon: '‚ÜØ', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'ÌäπÏàò: Î∏îÎßÅÌÅ¨' },
        aegis:     { name: 'Ïù¥ÏßÄÏä§', icon: 'üõ°Ô∏è', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'ÌäπÏàò: Î∞©Ïñ¥Îßâ' },
        berserker: { name: 'Î≤ÑÏÑúÏª§', icon: 'üî•', unlocked: false, attackDesc: 'Ï≤¥Î†• ÎπÑÎ°Ä Í≥µÏÜç Ï¶ùÍ∞Ä', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        tempest:   { name: 'ÌÖúÌéòÏä§Ìä∏', icon: 'üåÄ', unlocked: false, attackDesc: 'Í≥µÏ†Ñ Ïò§Î∏åÏ†ùÌä∏', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        phase:     { name: 'ÌéòÏù¥Ï¶à', icon: '¬ª', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'ÌäπÏàò: Î¨¥Ï†Å ÎåÄÏãú' },
        echo:      { name: 'ÏóêÏΩî',   icon: '‚Ü∫', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'ÌäπÏàò: Ìå®ÎßÅ/Î∞òÍ≤©' },
        comet:     { name: 'ÏΩîÎ©ß',   icon: '‚òÑÔ∏è', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'Ï¥àÍ≥†ÏÜç Í∏∞Îèô, Ï≤¥Î†• -1' },
        arbiter:   { name: 'ÏïÑÎπÑÌÑ∞', icon: '‚ñí', unlocked: false, attackDesc: 'Í∑ºÍ±∞Î¶¨ ÏÉ∑Í±¥', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        sentry:    { name: 'ÏÑºÌä∏Î¶¨', icon: 'T', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'ÌäπÏàò: ÌÑ∞Î†õ ÏÑ§Ïπò' },
        conjuror:  { name: 'Ïª®Ï†ÄÎü¨', icon: '‚ÅÇ', unlocked: false, attackDesc: 'ÌëúÏ§ÄÌòï ÏÉ∑', specialDesc: 'ÌäπÏàò: ÏïÑÍµ∞ ÏÜåÌôò' },
        vector:    { name: 'Î≤°ÌÑ∞', icon: 'üìê', unlocked: false, attackDesc: 'Î¶¨ÏΩîÏ≥á ÌÉÑÌôò', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        nebula:    { name: 'ÎÑ§Î∑∏Îùº', icon: 'üåå', unlocked: false, attackDesc: 'ÌôïÏû• ÏÑ±Ïö¥ Íµ¨Ï≤¥', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        vortex:    { name: 'Î≥ºÌÖçÏä§', icon: 'üå™Ô∏è', unlocked: false, attackDesc: 'ÎÇòÏÑ†Ìòï ÌöåÏ†ÑÌÉÑ', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        prism:     { name: 'ÌîÑÎ¶¨Ï¶ò', icon: 'üåà', unlocked: false, attackDesc: 'Î∂ÑÏó¥Ìòï Î†àÏù¥Ï†Ä', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
        chaos:     { name: 'Ïπ¥Ïò§Ïä§', icon: 'üé≤', unlocked: false, attackDesc: 'Î¨¥ÏûëÏúÑ Ìå®ÌÑ¥', specialDesc: 'Ï†ÑÏ≤¥ ÌôîÎ©¥ Ìè≠ÌÉÑ' },
    };
    
    function initializeCharacterData(charObject) {
        Object.keys(charObject).forEach(id => {
            if (!charObject[id].skins) {
                charObject[id].highScore = charObject[id].highScore || 0;
                charObject[id].selectedSkin = charObject[id].selectedSkin || 'default';
                charObject[id].skins = { default: { unlocked: true }, normal: { unlocked: false }, rare: { unlocked: false }, legendary: { unlocked: false }, mythic: { unlocked: false } };
            }
        });
        return charObject;
    }
    characters = initializeCharacterData(characters);

    let upgrades = { power: { name: 'ÏãúÏûë ÌååÏõå', level: 0, maxLevel: 3, cost: [1000, 3000, 7000] }, bombs: { name: 'ÏãúÏûë Ìè≠ÌÉÑ', level: 0, maxLevel: 2, cost: [2000, 5000] }, gauge: { name: 'Í≤åÏù¥ÏßÄ Ìö®Ïú®', level: 0, maxLevel: 4, cost: [1500, 3500, 6000, 9000] }, magnet: { name: 'ÏïÑÏù¥ÌÖú ÏûêÏÑù', level: 0, maxLevel: 1, cost: [10000] } };

    const MISSIONS = {
        score10k: { desc: "Ìïú Í≤åÏûÑÏóêÏÑú 10,000Ï†ê Îã¨ÏÑ±ÌïòÍ∏∞", target: 10000, reward: 500, trackerKey: 'maxScore' },
        score100k: { desc: "Ìïú Í≤åÏûÑÏóêÏÑú 100,000Ï†ê Îã¨ÏÑ±ÌïòÍ∏∞", target: 100000, reward: 2000, trackerKey: 'maxScore' },
        kills100: { desc: "Ï¥ù 100Í∏∞ Ï†Å Í≤©ÌååÌïòÍ∏∞", target: 100, reward: 250, trackerKey: 'totalKills' },
        kills1000: { desc: "Ï¥ù 1,000Í∏∞ Ï†Å Í≤©ÌååÌïòÍ∏∞", target: 1000, reward: 1000, trackerKey: 'totalKills' },
        graze500: { desc: "Ï¥ù 500Ìöå Í∑∏Î†àÏù¥Ï¶àÌïòÍ∏∞", target: 500, reward: 750, trackerKey: 'totalGraze' },
        wave10: { desc: "Ïõ®Ïù¥Î∏å 10 ÎèÑÎã¨ÌïòÍ∏∞", target: 10, reward: 1500, trackerKey: 'maxWave' },
        shards5k: { desc: "Ï¥ù 5,000 ÏÉ§Îìú ÌöçÎìùÌïòÍ∏∞", target: 5000, reward: 500, trackerKey: 'totalShardsEarned' },
        shards20k: { desc: "Ï¥ù 20,000 ÏÉ§Îìú ÌöçÎìùÌïòÍ∏∞", target: 20000, reward: 2000, trackerKey: 'totalShardsEarned' },
        play10: { desc: "Ï¥ù 10Ìöå ÌîåÎ†àÏù¥ÌïòÍ∏∞", target: 10, reward: 500, trackerKey: 'gamesPlayed' },
        unlock5: { desc: "Ï∫êÎ¶≠ÌÑ∞ 5Ï¢Ö Ìï¥Í∏àÌïòÍ∏∞", target: 5, reward: 1000, trackerKey: 'unlockedCharCount' },
    };

    const TITLES = {
        rookie: { name: "Ïã†ÏûÖ ÌååÏùºÎüø", desc: "Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÎ©¥ ÌöçÎìù" },
        scorer: { name: "Ïä§ÏΩîÏñ¥Îü¨", desc: "100,000Ï†ê Îã¨ÏÑ± ÎØ∏ÏÖò ÏôÑÎ£å", requiresMission: 'score100k' },
        hunter: { name: "ÏÇ¨ÎÉ•Íæº", desc: "1,0000Í∏∞ Í≤©Ìåå ÎØ∏ÏÖò ÏôÑÎ£å", requiresMission: 'kills10000' },
        dancer: { name: "ÌÉÑÎßâ Î¨¥Ïö©Ïàò", desc: "5000Ìöå Í∑∏Î†àÏù¥Ï¶à ÎØ∏ÏÖò ÏôÑÎ£å", requiresMission: 'graze5000' },
        veteran: { name: "Î≤†ÌÖåÎûë", desc: "Ïõ®Ïù¥Î∏å 10 ÎèÑÎã¨ ÎØ∏ÏÖò ÏôÑÎ£å", requiresMission: 'wave10' },
        collector: { name: "ÏàòÏßëÍ∞Ä", desc: "Ï∫êÎ¶≠ÌÑ∞ 10Ï¢Ö Ìï¥Í∏à ÎØ∏ÏÖò ÏôÑÎ£å", requiresMission: 'unlock10' },
        rich: { name: "ÏãúÍ∞Ñ Î∂ÄÏûê", desc: "100,000 ÏÉ§Îìú ÌöçÎìù ÎØ∏ÏÖò ÏôÑÎ£å", requiresMission: 'shards100k' },
        chronoMaster: { name: "ÌÅ¨Î°úÎÖ∏ ÎßàÏä§ÌÑ∞", desc: "Ïã†Ìôî Ïä§ÌÇ® ÌöçÎìù", requiresMythic: true },
    };

    // --- 2. ÏÇ¨Ïö¥Îìú ÏãúÏä§ÌÖú ---
    let audioContext; const audioBuffers = {};
    const soundAssets = { shoot: 'data:audio/wav;base64,UklGRlgAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAP//AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8=', explosion: 'data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSgAAAA+Pj8/Pz4+Pj4+Pj49PT09PTw8PDs7Ozo6Ojk5OTg4ODc3Njc2NjU1NTQ0NDMzMzIyMjExMTAwLy8uLSwrKikoJyYmJSUlJCQkIyIiISAgHx4eHBsaGRgXFhUUExITEREOBwgFBAIB', graze: 'data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAA//8BAAECBQQHCAkKCw0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0A=', playerHit: 'data:audio/wav;base64,UklGRmAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YVwAAABAAAD8AP4A/gD9APwA+wD5APgA9wD0APMA8gDxAPAA7wDsAOsA6ADnAOYA4wDiAOEA3wDcANsA2ADRANAAzwDMAssCyQLEAsECwQHCAb8BvgG9AbwBvQG+Ab8BwgHCAsECwQLFAsYCyQLLAMwA0ADSANkA3ADeAOAA4wDnAOoA7QDyAPUA+gD/AAQBCgEQARYBGgEcASQBKgEuATMBPAE/AUQBSgFOAVIBVwFYAVwBXgFiAWgBbAFwAW8BcgF3AXgBewF9AX8BfwF+AXwBcgFvAWwBagFkAWQBZAFhAVgBUwFPAUkBRQFBAT4BOgEwASoBJwEhARwBFgEOAQsBBgECAP4A+wD0AO0A5wDhANkA0AC/AbwBsgGnAZwBlgGRAZAAkAGSAZgBoQGwAbwBwwHNAeYB+gIIAhMCHQImAiwCMAI3Aj4CRQJMAloCXQJgAmYCcAJ2AoACjgKiAq4CwgLPAtgC4gLrAvUC+wL+AwIDBwMLAxcDGgMiAykDMANAA0sDWANgA2gDcAN8A4gDkQOcA6sDtQO/A8wD3APqA/0DAwQIBhEKDxQVGh0gIycoMDM5PEBHS1JcYW5xfISQlp+lrsbT3+n6/w==', itemGet: 'data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YRoAAAAaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc=', chronoStart: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAPz49Ozg1MzExLy0rKCcmJSQjIiAfHhsZFRMREQ4HCAUEAgE=', chronoEnd: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAAgQFBwgODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygp', laser: 'data:audio/wav;base64,UklGRlQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUwDAAB/f3+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1VWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==', blink: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAADg3uLa0s/LxcC4t7GuqaSgmpaTkZGNi4eCfnx3cWpnZWBgXVpYVFFOTEpIRkBERUJGQj89Ojg1NC8uKScnJSUlJCQjIiEgHx4cHBsaGRgXFhUUExITEREOBwgFBAIB', shieldUp: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAQUJDREVGR0hJSktMTU5PUFFSU1VWV1hZWltcXV5fYGFiY2RlZmdoaQ==', shieldDown: 'data:audio/wav;base64,UklGRkAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAAaGlmZWRjYmFfYV5dWltZWFhVVFNRS0dFRENCQUA/PTw6OQ==', parry: 'data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSAAAAAA+vr5+Pb18/Lx7+/u7ezr6ufm5eHh39/e3dza2dvY19XU09LR0M/NzMvKyMfGxcLDv728ubq5t7S0s6+ur6yqp6SjoZ+dm5iWlZGOjYqHh4B+fXt4doA=' };
    async function initAudio() { if (audioContext) return; try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); for (const name of Object.keys(soundAssets)) { const response = await fetch(soundAssets[name]); const arrayBuffer = await response.arrayBuffer(); audioBuffers[name] = await audioContext.decodeAudioData(arrayBuffer); } } catch (e) { console.error("Web Audio API error", e); } }
    function playSound(name, volume = 0.7) { if (!audioContext || !audioBuffers[name] || audioContext.state === 'suspended') return; const source = audioContext.createBufferSource(); source.buffer = audioBuffers[name]; const gainNode = audioContext.createGain(); gainNode.gain.value = volume; source.connect(gainNode); gainNode.connect(audioContext.destination); source.start(0); }

    // --- 3. ÌÅ¥ÎûòÏä§ Ï†ïÏùò ---
    class Player {
        constructor() {
            this.x = canvas.width / 2; this.y = canvas.height - 80; this.size = 12; this.hitboxSize = 4; this.grazeRadius = 40; this.speed = 280;
            this.shootCooldown = 0; this.isInvincible = false; this.invincibleTimer = 0; this.chronoGauge = 0; this.chronoGaugeMax = 100;
            this.power = 1 + upgrades.power.level;
            
            let baseLives = 3; if (selectedCharacterId === 'blade' || selectedCharacterId === 'comet') baseLives = 2; this.lives = baseLives;
            
            const charData = characters[selectedCharacterId];
            this.skin = charData.selectedSkin;
            this.skinData = SKIN_DATA[selectedCharacterId][this.skin];
            this.color = this.skinData.shipColor;
            this.attackColor = this.skinData.attackColor;
            this.accentColor = this.skinData.accentColor;
            this.skinRarity = SKIN_RARITY[this.skin];

            const specialBombChars = ['rift', 'aegis', 'phase', 'echo', 'sentry', 'conjuror'];
            const initialBombs = (specialBombChars.includes(selectedCharacterId)) ? 0 : 3 + upgrades.bombs.level + (selectedCharacterId === 'guardian' ? 1 : 0);
            this.bombs = Math.min(5, initialBombs);
            
            if (selectedCharacterId === 'comet') this.speed *= 1.4;
            this.chargeLevel = 0; this.chargeMax = 1.5;
            this.blinkCooldown = 0; this.blinkMaxCooldown = 5;
            this.dashCooldown = 0; this.dashMaxCooldown = 1.5;
            this.parryCooldown = 0; this.parryMaxCooldown = 2.0; // ECHO BALANCE
            this.isParrying = false; this.parryTimer = 0; this.parryPower = 0;
            this.phaseBoostTimer = 0; this.phaseBoostDuration = 3.0;
            this.stationaryTimer = 0; this.nebulaBonus = 1; // Nebula passive
            this.killStreak = 0; this.vortexPower = 1; // Vortex growth system
            this.prismChain = 0; this.prismChainTimer = 0; // Prism chain system
            this.chaosTimer = 0; this.chaosPattern = 0; // Chaos randomness
            this.orbiters = []; this.orbiterCooldown = 0;
            this.isShielding = false; this.shieldTimer = 0; this.shieldPower = 0;
            this.turretCooldown = 0; this.turretMaxCooldown = 18; // Increased cooldown
            this.summonCooldown = 0; this.summonMaxCooldown = 15;
        }
        update(deltaTime, input) {
            if (this.skinData.hasTrail) { particles.push(new Particle(this.x, this.y, this.accentColor, 3, { lifespan: 0.3, fade: true, type: 'trail' })); }
            let moveX = 0, moveY = 0; if (input.keys.ArrowLeft || input.keys.a) moveX -= 1; if (input.keys.ArrowRight || input.keys.d) moveX += 1; if (input.keys.ArrowUp || input.keys.w) moveY -= 1; if (input.keys.ArrowDown || input.keys.s) moveY += 1;
            if (controlMode === 'touch' && input.touch.active) { const dx = input.touch.x - this.x, dy = input.touch.y - this.y, dist = Math.hypot(dx, dy); if (dist > 1) { moveX = dx / dist; moveY = dy / dist; } }
            const isMoving = moveX !== 0 || moveY !== 0 || (controlMode === 'touch' && input.touch.active);
            if (!this.isShielding) {
                const effectiveSpeed = this.speed * deltaTime * (gameSpeed < 1 ? 1.5 : 1); this.x += moveX * effectiveSpeed; this.y += moveY * effectiveSpeed;
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            }
            let shootCooldownMultiplier = 1;
            if (selectedCharacterId === 'phase' && this.phaseBoostTimer > 0) {
                shootCooldownMultiplier = 0.3; // 3x faster shooting
            }
            this.shootCooldown -= deltaTime / shootCooldownMultiplier;
            
            if (selectedCharacterId === 'nova') {
                if (!isMoving) {
                    this.chargeLevel = Math.min(this.chargeMax, this.chargeLevel + deltaTime);
                }
                // When moving, the main shoot loop handles firing. Don't reset charge here.
            }
            
            if (this.shootCooldown <= 0 && !this.isShielding && !(selectedCharacterId === 'nova' && !isMoving)) {
                this.shoot();
            }

            if (this.isInvincible) { this.invincibleTimer -= deltaTime; if (this.invincibleTimer <= 0) this.isInvincible = false; }
            const gaugeConsumption = 25 * (1 - (upgrades.gauge.level * 0.1));
            if ((input.keys.Shift || input.touch.chronoActive) && this.chronoGauge > 0) { if(gameSpeed === 1) playSound('chronoStart'); gameSpeed = 0.25; this.chronoGauge -= gaugeConsumption * deltaTime; if (this.chronoGauge < 0) this.chronoGauge = 0; } else { if(gameSpeed < 1) playSound('chronoEnd'); gameSpeed = 1; }
            
            const bombPressed = input.keys.x || input.touch.bombPressed;
            if(bombPressed) { input.keys.x = false; input.touch.bombPressed = false; }
            
            this.turretCooldown = Math.max(0, this.turretCooldown - deltaTime);
            this.summonCooldown = Math.max(0, this.summonCooldown - deltaTime);
            this.parryCooldown = Math.max(0, this.parryCooldown - deltaTime);
            this.phaseBoostTimer = Math.max(0, this.phaseBoostTimer - deltaTime);
            
            // Nebula passive: stationary bonus
            if (selectedCharacterId === 'nebula') {
                if (isMoving) {
                    this.stationaryTimer = 0;
                    this.nebulaBonus = 1;
                } else {
                    this.stationaryTimer += deltaTime;
                    this.nebulaBonus = 1 + Math.min(this.stationaryTimer * 0.5, 2); // Up to 3x bonus after 4 seconds
                }
            }
            
            // Vortex passive: kill streak power
            if (selectedCharacterId === 'vortex') {
                this.vortexPower = 1 + Math.min(this.killStreak * 0.1, 1.5); // Up to 2.5x power
            }
            
            // Prism passive: chain reaction timer
            if (selectedCharacterId === 'prism') {
                this.prismChainTimer = Math.max(0, this.prismChainTimer - deltaTime);
                if (this.prismChainTimer <= 0) {
                    this.prismChain = 0;
                }
            }
            
            // Chaos passive: random pattern changes
            if (selectedCharacterId === 'chaos') {
                this.chaosTimer += deltaTime;
                if (this.chaosTimer >= 2.0) { // Change pattern every 2 seconds
                    this.chaosPattern = Math.floor(Math.random() * 4);
                    this.chaosTimer = 0;
                }
            }

            if (selectedCharacterId === 'rift') { this.blinkCooldown = Math.max(0, this.blinkCooldown - deltaTime); if (bombPressed && this.blinkCooldown <= 0) this.useBlink(isMoving ? {x: moveX, y: moveY} : null); }
            else if (selectedCharacterId === 'phase') { this.dashCooldown = Math.max(0, this.dashCooldown - deltaTime); if (bombPressed && this.dashCooldown <= 0) this.useDash(moveX, moveY); }
            else if (selectedCharacterId === 'echo') { this.parryTimer = Math.max(0, this.parryTimer - deltaTime); if(this.isParrying && this.parryTimer <= 0) this.releaseParry(); if (bombPressed && !this.isParrying && this.parryCooldown <= 0) this.activateParry(); }
            else if (selectedCharacterId === 'aegis') { if (bombPressed) this.toggleAegisShield(); if (this.isShielding) { this.shieldTimer -= deltaTime; if (this.shieldTimer <= 0) this.toggleAegisShield(); } }
            else if (selectedCharacterId === 'tempest') { this.orbiters.forEach((orb, i) => orb.update(deltaTime, this, i, this.orbiters.length)); if (this.orbiters.length < this.power) { this.orbiterCooldown -= deltaTime; if (this.orbiterCooldown <= 0) { this.orbiters.push(new Bullet(this.x, this.y, 0, 0, 'player', {isOrbiter: true, color:this.attackColor, accentColor:this.accentColor})); this.orbiterCooldown = 2.0; } } }
            else if (selectedCharacterId === 'sentry') { if (bombPressed && this.turretCooldown <= 0) this.deployTurret(); }
            else if (selectedCharacterId === 'conjuror') { if (bombPressed && this.summonCooldown <= 0) this.summonAllies(); }
            else if (bombPressed && this.bombs > 0) { this.useBomb(); }
        }
        draw(ctx) {
            if (this.isInvincible && Math.floor(this.invincibleTimer * 10) % 2 === 0) return;
            ctx.shadowColor = this.color; ctx.shadowBlur = this.skinRarity > 0 ? 5 + this.skinRarity * 4 : 5;
            if (this.skinRarity === 4) { const auraSize = this.size * (1.5 + Math.sin(Date.now() / 200) * 0.2); const gradient = ctx.createRadialGradient(this.x, this.y, this.size * 0.5, this.x, this.y, auraSize); gradient.addColorStop(0, this.accentColor + '80'); gradient.addColorStop(1, this.accentColor + '00'); ctx.fillStyle = gradient; ctx.fillRect(this.x - auraSize, this.y - auraSize, auraSize * 2, auraSize * 2); }
            
            const geometry = SKIN_GEOMETRY[this.skinData.geometry] || SKIN_GEOMETRY.default;
            ctx.fillStyle = this.color; ctx.beginPath();
            geometry.forEach((p, i) => { const xPos = this.x + p.x * this.size; const yPos = this.y + p.y * this.size; if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos); });
            ctx.closePath(); ctx.fill();
            ctx.shadowBlur = 0;
            if (selectedCharacterId === 'nova' && this.chargeLevel > 0) { ctx.strokeStyle = this.attackColor; ctx.lineWidth = 1 + (this.chargeLevel / this.chargeMax) * 3; ctx.globalAlpha = this.chargeLevel / this.chargeMax; ctx.beginPath(); ctx.arc(this.x, this.y, this.size + this.chargeLevel * 5, 0, Math.PI * 2); ctx.stroke(); ctx.globalAlpha = 1; }
            if (this.isShielding) { ctx.fillStyle = this.accentColor + '40'; ctx.strokeStyle = this.accentColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x, this.y, 30, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
            if (this.isParrying) { ctx.fillStyle = this.accentColor; ctx.globalAlpha = 0.5 + Math.sin(this.parryTimer * 50) * 0.5; ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
        }
        shoot() {
            let p = Math.min(this.power, 5); let bulletOptions = { color: this.attackColor, accentColor: this.accentColor, skinRarity: this.skinRarity };
            this.shootCooldown = 0.12;
            if (selectedCharacterId === 'berserker') { this.shootCooldown *= (0.5 + 0.5 * (this.lives / 3)); } // BALANCE: Nerfed
            else if (selectedCharacterId === 'spectre') { this.shootCooldown = 0.35; }
            else if (selectedCharacterId === 'arbiter') { this.shootCooldown = 0.4; }
            else if (selectedCharacterId === 'pulse') { this.shootCooldown = 0.6; }
            else if (selectedCharacterId === 'nebula') { this.shootCooldown = 0.8; } // Slow but powerful
            else if (selectedCharacterId === 'vortex') { this.shootCooldown = 0.25; } // Medium speed
            else if (selectedCharacterId === 'prism') { this.shootCooldown = 0.3; } // Medium speed
            else if (selectedCharacterId === 'chaos') { this.shootCooldown = 0.05 + Math.random() * 0.4; } // Random speed!
            playSound('shoot', 0.3);
            switch (selectedCharacterId) {
                case 'tempest': return;
                case 'arbiter': for(let i=0; i < 3 + p; i++) { bullets.push(new Bullet(this.x, this.y, -90 + (Math.random() - 0.5) * 45, 700 + Math.random() * 200, 'player', bulletOptions)); } break;
                case 'vector': 
                    // Ricochet bullets
                    for(let i=0; i<Math.min(p, 3); i++) {
                        bullets.push(new Bullet(this.x, this.y, -90 + (i-1) * 15, 600, 'player', { 
                            ...bulletOptions, 
                            bouncesLeft: 2 + Math.floor(p/2),
                            bounceBonus: 1.5 // Damage multiplier per bounce
                        })); 
                    }
                    break;
                case 'nebula':
                    // Expanding nebula orbs - devastating cosmic power
                    bullets.push(new Bullet(this.x, this.y, -90, 300, 'player', { 
                        ...bulletOptions, 
                        isNebulaOrb: true, 
                        size: 12 + p * 4,
                        expansionRate: 0.7 * this.nebulaBonus,
                        maxSize: 40 + p * 10,
                        isPiercing: true,
                        width: 24 + p * 8,
                        height: 24 + p * 8,
                        damage: (720 + p * 240) * this.nebulaBonus // Massive damage increase
                    })); 
                    break;
                case 'vortex':
                    // Spiral rotating bullets - grows stronger with kills
                    const vortexCount = Math.min(2 + Math.floor(p/2), 4);
                    for(let i = 0; i < vortexCount; i++) {
                        const angle = -90 + (i - (vortexCount-1)/2) * 15;
                        bullets.push(new Bullet(this.x, this.y, angle, 500, 'player', { 
                            ...bulletOptions, 
                            isVortex: true, 
                            spiralRate: 2 + this.killStreak * 0.1,
                            damage: (8 + p * 2) * this.vortexPower
                        })); 
                    }
                    break;
                case 'prism':
                    // Splitting laser beam
                    bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', { 
                        ...bulletOptions, 
                        isPrism: true, 
                        splitsLeft: 1 + Math.floor(p/2),
                        damage: 12 + p * 3,
                        chainBonus: this.prismChain
                    })); 
                    break;
                case 'chaos':
                    // Random pattern bullets
                    const chaosCount = 1 + Math.floor(Math.random() * (3 + p));
                    for(let i = 0; i < chaosCount; i++) {
                        const randomAngle = -90 + (Math.random() - 0.5) * 90;
                        const randomSpeed = 300 + Math.random() * 400;
                        bullets.push(new Bullet(this.x, this.y, randomAngle, randomSpeed, 'player', { 
                            ...bulletOptions, 
                            size: 3 + Math.random() * 4,
                            damage: 8 + p * 2 + Math.random() * 5
                        })); 
                    }
                    break;
                case 'sentry':
                    // Weakened standard shot for balance (since turrets provide main damage)
                    if (p === 1) { 
                        bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { ...bulletOptions, damage: 6 })); // Reduced speed and damage
                    } else if (p === 2) { 
                        bullets.push(new Bullet(this.x - 5, this.y, -90, 600, 'player', { ...bulletOptions, damage: 6 })); 
                        bullets.push(new Bullet(this.x + 5, this.y, -90, 600, 'player', { ...bulletOptions, damage: 6 })); 
                    } else { 
                        bullets.push(new Bullet(this.x - 10, this.y, -90, 600, 'player', { ...bulletOptions, damage: 6 })); 
                        bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { ...bulletOptions, damage: 6 })); 
                        bullets.push(new Bullet(this.x + 10, this.y, -90, 600, 'player', { ...bulletOptions, damage: 6 })); 
                    }
                    break;
                case 'nova': if (this.chargeLevel >= this.chargeMax) { playSound('laser', 0.8); bullets.push(new Bullet(this.x, canvas.height / 2, -90, 0, 'player', { ...bulletOptions, isPiercing: true, isLaser: true, width: 15 + p * 5, height: canvas.height, lifespan: 0.3 })); this.chargeLevel = 0; this.shootCooldown = 0.5; } break; // No default shot
                case 'blade': bullets.push(new Bullet(this.x, this.y, -90, 1200, 'player', { ...bulletOptions, isPiercing: true, width: 4 + p, height: 40 })); break;
                case 'pulse': bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { ...bulletOptions, isWave: true, size: 15 + p * 5, lifespan: 0.2 })); break;
                case 'spectre': bullets.push(new Bullet(this.x, this.y, -90, 400, 'player', { ...bulletOptions, isHoming: true })); if (p >= 3) bullets.push(new Bullet(this.x - 15, this.y, -90, 400, 'player', { ...bulletOptions, isHoming: true })); if (p >= 5) bullets.push(new Bullet(this.x + 15, this.y, -90, 400, 'player', { ...bulletOptions, isHoming: true })); break;
                case 'guardian': bullets.push(new Bullet(this.x, this.y, -90, 700, 'player', bulletOptions)); for(let i=1; i<=Math.floor(p/2); i++) { bullets.push(new Bullet(this.x, this.y, -90 - i * 15, 700, 'player', bulletOptions)); bullets.push(new Bullet(this.x, this.y, -90 + i * 15, 700, 'player', bulletOptions)); } break;
                default: 
                    let bulletSize = selectedCharacterId === 'phase' && this.phaseBoostTimer > 0 ? 8 : 5; // Bigger bullets during boost
                    let enhancedOptions = {...bulletOptions, size: bulletSize};
                    
                    if (p === 1) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', enhancedOptions)); } 
                    else if (p === 2) { bullets.push(new Bullet(this.x - 5, this.y, -90, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x + 5, this.y, -90, 800, 'player', enhancedOptions)); } 
                    else if (p === 3) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x, this.y, -85, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x, this.y, -95, 800, 'player', enhancedOptions)); } 
                    else if (p === 4) { bullets.push(new Bullet(this.x - 8, this.y, -90, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x + 8, this.y, -90, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x - 4, this.y, -85, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x + 4, this.y, -95, 800, 'player', enhancedOptions)); } 
                    else if (p >= 5) { bullets.push(new Bullet(this.x, this.y, -90, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x, this.y, -80, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x, this.y, -100, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x - 10, this.y, -90, 800, 'player', enhancedOptions)); bullets.push(new Bullet(this.x + 10, this.y, -90, 800, 'player', enhancedOptions)); } 
                    break;
            }
        }
        takeHit() { if (this.isInvincible) return; if (this.isParrying) { this.parryPower++; return; } if (this.isShielding) return; playSound('playerHit'); screenShake = 15; this.lives--; this.power = Math.max(1, this.power - 1); if (selectedCharacterId === 'tempest') this.orbiters.pop(); this.isInvincible = true; this.invincibleTimer = 2; createExplosion(this.x, this.y, this.color, 40); if (this.lives < 0) { gameOver(); } }
        addChronoGauge(amount) { const lateGamePenalty = Math.max(0.3, 1 - (wave * 0.05)); this.chronoGauge = Math.min(this.chronoGaugeMax, this.chronoGauge + amount * lateGamePenalty); if (this.skinRarity === 4) { for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, this.accentColor, 3, { type: 'spark' })); } }
        useBomb() { if (this.bombs <= 0) return; this.bombs--; playSound('explosion', 1.0); this.isInvincible = true; this.invincibleTimer = 1.5; bullets = bullets.filter(b => b.owner !== 'enemy'); enemies.forEach(e => e.takeDamage(50)); createScreenFlash(); if (this.skinData.hasSkillEffect) { createFireworkExplosion(this.x, this.y - 100, this.attackColor, this.accentColor, 50); } }
        useBlink(direction) { playSound('blink'); this.blinkCooldown = this.blinkMaxCooldown; this.isInvincible = true; this.invincibleTimer = 0.3; const blinkDist = 100; if (this.skinData.hasSkillEffect) { createExplosion(this.x, this.y, this.accentColor, 20, { type: 'warp', speed: 800 }); } else { createExplosion(this.x, this.y, this.color, 20, { type: 'warp' }); } if(direction) { this.x += direction.x * blinkDist; this.y += direction.y * blinkDist; } else { this.y -= blinkDist; } this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x)); this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y)); createExplosion(this.x, this.y, this.color, 20, { type: 'warp' }); }
        useDash(moveX, moveY) { playSound('blink', 0.5); this.dashCooldown = this.dashMaxCooldown; this.isInvincible = true; this.invincibleTimer = 0.2; const dashDist = 60; if (this.skinData.hasSkillEffect) { for (let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, this.accentColor, 4, {lifespan: 0.5, fade: true})); } createExplosion(this.x, this.y, this.color, 15, { type: 'warp', speed: 300 }); let dirX = moveX, dirY = moveY; if (dirX === 0 && dirY === 0) dirY = -1; const mag = Math.hypot(dirX, dirY); this.x += (dirX/mag) * dashDist; this.y += (dirY/mag) * dashDist; }
        activateParry() { this.parryCooldown = this.parryMaxCooldown; this.isParrying = true; this.parryTimer = 0.25; this.parryPower = 0; if (this.skinData.hasSkillEffect) { createExplosion(this.x, this.y, this.accentColor, 15, {speed: 100}); } }
        releaseParry() { this.isParrying = false; if (this.parryPower > 0) { playSound('parry'); for(let i=0; i<this.parryPower; i++) { const angle = -90 + (Math.random() - 0.5) * 60; bullets.push(new Bullet(this.x, this.y, angle, 900, 'player', { size: 8, isPiercing: true, width: 8, height: 20, color: this.accentColor, accentColor: this.color })); } } }
        toggleAegisShield() { this.isShielding = !this.isShielding; if (this.isShielding) { playSound('shieldUp'); this.shieldTimer = 2.0; this.shieldPower = 0; if (this.skinData.hasSkillEffect) { for(let i=0; i<36; i++) { particles.push(new Particle(this.x, this.y, this.accentColor, 2, {speed: 100, lifespan: 0.5, type: 'spark'})); } } } else { playSound('shieldDown'); if (this.shieldPower > 0) { bullets.push(new Bullet(this.x, this.y, -90, 600, 'player', { isWave: true, size: 20 + this.shieldPower * 2, lifespan: 0.5, color: this.attackColor, accentColor: this.accentColor })); } } }
        deployTurret() { playSound('shieldUp'); this.turretCooldown = this.turretMaxCooldown; turrets.push(new Turret(this.x, this.y, this.power, this.attackColor)); if (this.skinData.hasSkillEffect) { createExplosion(this.x, this.y, this.accentColor, 30); } }
        summonAllies() { playSound('itemGet'); this.summonCooldown = this.summonMaxCooldown; allies.push(new Ally(this.x - 20, this.y, this.power, this.attackColor)); allies.push(new Ally(this.x + 20, this.y, this.power, this.attackColor)); if (this.skinData.hasSkillEffect) { createExplosion(this.x, this.y, this.accentColor, 30, {type: 'spark'}); } }
    }
    class Bullet {
        constructor(x, y, angle, speed, owner, special = {}) {
            this.x = x; this.y = y; this.owner = owner; this.special = special;
            this.color = (owner === 'player' && special.color) ? special.color : colors.enemyBullet;
            if (special.isWave) { this.size = special.size; this.lifespan = special.lifespan; } 
            else if (special.isNebulaOrb) { this.size = special.size; this.width = special.width; this.height = special.height; this.hitEnemies = new Set(); }
            else if (special.isPiercing) { this.width = special.width; this.height = special.height; this.hitEnemies = new Set(); }
            else if (special.isVortex) { this.size = special.size || 5; this.spiralAngle = 0; this.hitEnemies = new Set(); }
            else if (special.isPrism) { this.size = special.size || 6; this.hitEnemies = new Set(); }
            else if (special.isOrbiter) { this.size = 8; this.angle = 0; } 
            else { this.size = special.size || 5; }
            const rad = angle * Math.PI / 180; this.vx = Math.cos(rad) * speed; this.vy = Math.sin(rad) * speed; this.grazed = false;
        }
        update(deltaTime, playerRef, index, totalOrbiters) {
            if (this.special.isOrbiter) { const baseAngle = (Date.now() / 1000) * 1.5; const offsetAngle = (Math.PI * 2 / totalOrbiters) * index; this.x = playerRef.x + Math.cos(baseAngle + offsetAngle) * 60; this.y = playerRef.y + Math.sin(baseAngle + offsetAngle) * 60; return; }
            if (this.special.isHoming && this.owner === 'player') { let closestEnemy = null, minDist = Infinity; for (const enemy of enemies) { const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < minDist) { minDist = dist; closestEnemy = enemy; } } if (closestEnemy) { const angleToTarget = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x); this.vx += Math.cos(angleToTarget) * 2000 * deltaTime; this.vy += Math.sin(angleToTarget) * 2000 * deltaTime; const speed = Math.hypot(this.vx, this.vy), maxSpeed = 400; if (speed > maxSpeed) { this.vx = (this.vx / speed) * maxSpeed; this.vy = (this.vy / speed) * maxSpeed; } } }
            if (this.special.lifespan) { this.lifespan -= deltaTime; }
            this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed;
            if (this.special.bouncesLeft > 0) { 
                if (this.x < 0 || this.x > canvas.width) { 
                    this.vx *= -1; 
                    this.special.bouncesLeft--; 
                    if (this.special.bounceBonus) {
                        this.special.damage = (this.special.damage || 10) * this.special.bounceBonus;
                    }
                } 
                if (this.y < 0) { 
                    this.vy *= -1; 
                    this.special.bouncesLeft--; 
                    if (this.special.bounceBonus) {
                        this.special.damage = (this.special.damage || 10) * this.special.bounceBonus;
                    }
                } 
            }
            
            if (this.special.isNebulaOrb) {
                this.size = Math.min(this.special.maxSize, this.size + this.special.expansionRate * deltaTime * 10);
                this.width = this.height = this.size * 2;
            }
            
            if (this.special.isVortex) {
                this.spiralAngle += this.special.spiralRate * deltaTime * gameSpeed;
                this.vx += Math.cos(this.spiralAngle) * 50 * deltaTime * gameSpeed;
                this.vy += Math.sin(this.spiralAngle) * 50 * deltaTime * gameSpeed;
            }
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            if (this.owner === 'player' && this.special.skinRarity > 1) { ctx.shadowColor = this.color; ctx.shadowBlur = this.special.skinRarity * 4; if (this.special.skinRarity > 2) { particles.push(new Particle(this.x, this.y, this.special.accentColor, this.size * 0.7, { lifespan: 0.3, fade: true })); } }
            ctx.beginPath();
            if (this.special.isLaser) { ctx.globalAlpha = this.lifespan / 0.3; ctx.fillStyle = this.special.accentColor; ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); ctx.fillStyle = this.color; ctx.fillRect(this.x - this.width/4, this.y - this.height/2, this.width/2, this.height); ctx.globalAlpha = 1.0; }
            else if (this.special.isWave) { ctx.globalAlpha = this.lifespan / this.special.lifespan; ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.globalAlpha = 1; }
            else if (this.special.isNebulaOrb) { 
                ctx.globalAlpha = 0.8;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.7, this.color + '80');
                gradient.addColorStop(1, this.color + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
            else if (this.special.isPiercing) { ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); }
            else if (this.special.isVortex) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.spiralAngle);
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.restore();
            }
            else if (this.special.isPrism) {
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, this.special.accentColor || this.color);
                ctx.fillStyle = gradient;
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            }
            else { ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); }
            ctx.fill(); ctx.shadowBlur = 0;
        }
    }
    class Enemy {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; const difficulty = 1 + wave * 0.22; this.init(difficulty); this.isElite = false; this.isSplitterFragment = false; if (wave > 10 && Math.random() < 0.1 && !this.isSplitterFragment) this.makeElite(difficulty); }
        init(difficulty) { this.shootTimer = Math.random() * 2 + 1; this.bulletSpeed = 250 * (1 + wave * 0.1); switch(this.type) { case 'bulwark': this.size = 25; this.health = 80 * difficulty; this.color = colors.bulwark; this.speed = 30; this.scoreValue = 500; break; case 'sentinel': this.size = 18; this.health = 20 * difficulty; this.color = colors.sentinel; this.speed = 20; this.scoreValue = 400; this.laserCharge = 0; this.laserMaxCharge = 3; break; case 'barrier': this.size = 20; this.health = 30 * difficulty; this.color = colors.barrier; this.speed = 50; this.scoreValue = 350; this.shieldHealth = 50 * difficulty; break; case 'dasher': this.size = 12; this.health = 10 * difficulty; this.color = colors.dasher; this.speed = 300; this.scoreValue = 150; this.vy = this.speed; this.vx = Math.random() > 0.5 ? 100 : -100; break; case 'weaver': this.size = 18; this.health = 25 * difficulty; this.color = colors.weaver; this.speed = 80; this.scoreValue = 250; this.baseX = this.x; this.angle = 0; break; case 'kamikaze': this.size = 15; this.health = 5 * difficulty; this.color = colors.kamikaze; this.speed = 150; this.scoreValue = 200; break; case 'basic': this.size = 15; this.health = 15 * difficulty; this.color = colors.enemy1; this.speed = 100; this.scoreValue = 100; break; case 'shooter': this.size = 20; this.health = 40 * difficulty; this.color = colors.enemy2; this.speed = 60; this.scoreValue = 300; break; case 'splitter': this.size = 22; this.health = 60 * difficulty; this.color = colors.splitter; this.speed = 50; this.scoreValue = 400; this.hasSplit = false; break; case 'summoner': this.size = 28; this.health = 120 * difficulty; this.color = colors.summoner; this.speed = 25; this.scoreValue = 800; this.summonTimer = 0; this.summonCooldown = 3; this.minionsSpawned = 0; this.maxMinions = 2; break; case 'boss': this.size = 50; this.health = (20000 + wave * 6000) * difficulty; this.maxHealth = this.health; this.color = colors.boss; this.speed = 50; this.scoreValue = 10000; this.pattern = 'entry'; this.patternTimer = 0; this.patternDuration = 8; this.bulletSpeed *= 1.2; this.moveTimer = 2; this.moveTargetX = this.x; this.waveDirection = 1; this.orbitalAngle = 0; this.guidedMissiles = []; this.lightningTargets = []; break; } }
        makeElite(difficulty) { this.isElite = true; this.health *= 2; this.bulletSpeed *= 1.2; this.color = '#FFD700'; this.scoreValue *= 3; if (this.shieldHealth) this.shieldHealth *= 2; }
        update(deltaTime) {
            switch(this.type) {
                case 'sentinel': if (this.y < 80) this.y += this.speed * deltaTime; this.laserCharge += deltaTime * gameSpeed; if (this.laserCharge >= this.laserMaxCharge) { this.shoot(); this.laserCharge = 0; } break;
                case 'dasher': this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed; if (this.x < 0 || this.x > canvas.width) this.vx *= -1; break;
                case 'weaver': this.y += this.speed * deltaTime * gameSpeed; this.angle += 3 * deltaTime * gameSpeed; this.x = this.baseX + Math.sin(this.angle) * 80; break;
                case 'kamikaze': if (player) { const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angleToPlayer) * this.speed * deltaTime * gameSpeed; this.y += Math.sin(angleToPlayer) * this.speed * deltaTime * gameSpeed; if (Math.hypot(this.x - player.x, this.y - player.y) < this.size + player.hitboxSize) { this.health = 0; player.takeHit(); } } break;
                case 'splitter': this.y += this.speed * deltaTime * gameSpeed; this.x += Math.sin(Date.now() * 0.002) * 20 * deltaTime; break;
                case 'summoner': if (this.y < 100) this.y += this.speed * deltaTime * gameSpeed; else { this.x += Math.sin(Date.now() * 0.001) * 30 * deltaTime; this.summonTimer += deltaTime * gameSpeed; if (this.summonTimer >= this.summonCooldown && this.minionsSpawned < this.maxMinions) { this.summonMinion(); this.summonTimer = 0; } } break;
                default: this.y += this.speed * deltaTime * gameSpeed; break;
            }
            this.shootTimer -= deltaTime * gameSpeed; if (this.shootTimer <= 0 && this.type !== 'sentinel' && this.type !== 'boss') this.shoot();
            if (this.type === 'boss') {
                // Movement with bounds checking
                if (this.y < 150) { 
                    this.y += this.speed * deltaTime; 
                } else { 
                    this.y = 150; // Keep boss at fixed Y position
                    this.moveTimer -= deltaTime;
                    if (this.moveTimer <= 0) {
                        this.moveTargetX = Math.random() * (canvas.width * 0.6) + (canvas.width * 0.2);
                        this.moveTimer = Math.random() * 3 + 2; // Move every 2-5 seconds
                    }
                    this.x += (this.moveTargetX - this.x) * 0.5 * deltaTime;
                    
                    // Ensure boss stays within screen bounds
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                }

                this.patternTimer += deltaTime; 
                this.shootTimer -= deltaTime;
                if(this.shootTimer <= 0) this.shoot();
                
                // Í∂§ÎèÑ ÌÉÄÍ≤©Ïö© Í∞ÅÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
                this.orbitalAngle += deltaTime * 2;
                
                // Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº ÏóÖÎç∞Ïù¥Ìä∏
                this.guidedMissiles = this.guidedMissiles.filter(missile => {
                    missile.update(deltaTime);
                    return missile.active;
                });
                
                // Î≤àÍ∞ú Í≥µÍ≤© ÌÉÄÍ≤ü ÏóÖÎç∞Ïù¥Ìä∏
                this.lightningTargets = this.lightningTargets.filter(target => {
                    target.timer -= deltaTime;
                    return target.timer > 0;
                });

                if (this.patternTimer >= this.patternDuration) {
                    this.patternTimer = 0;
                    const healthRatio = this.health / this.maxHealth;
                    const basicPatterns = ['crossfire', 'weave', 'sunburst', 'ricochet', 'spiral', 'spawn_minions'];
                    const advancedPatterns = ['tidal_wave', 'lightning_strike', 'orbital_strike', 'guided_missiles', 'area_blast'];
                    let nextPattern;
                    if (healthRatio < 0.2) {
                        nextPattern = 'desperate';
                    } else if (healthRatio < 0.5) {
                        // Under 50% health, add more difficult patterns to the mix
                        const allPatterns = basicPatterns.concat(advancedPatterns, ['sunburst', 'ricochet', 'desperate']);
                        nextPattern = allPatterns[Math.floor(Math.random() * allPatterns.length)];
                    } else {
                        const patterns = basicPatterns.concat(advancedPatterns);
                        nextPattern = patterns[Math.floor(Math.random() * patterns.length)];
                    }
                    this.pattern = nextPattern;
                }
            }
            // Only remove enemies that go off screen, but not bosses
            if (this.y > canvas.height + this.size && this.type !== 'boss') this.health = 0;
        }
        draw(ctx) {
            ctx.shadowColor = this.isElite ? '#FFD700' : this.color;
            ctx.shadowBlur = 10;
            ctx.fillStyle = this.color;
            ctx.strokeStyle = this.isElite ? '#FFD700' : '#FFF';
            ctx.lineWidth = this.isElite ? 3 : 1.5;

            ctx.beginPath();
            switch(this.type) {
                case 'basic':
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x + this.size * 0.8, this.y + this.size * 0.8);
                    ctx.lineTo(this.x - this.size * 0.8, this.y + this.size * 0.8);
                    break;
                case 'shooter':
                    ctx.moveTo(this.x - this.size, this.y - this.size * 0.5);
                    ctx.lineTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x + this.size, this.y - this.size * 0.5);
                    ctx.lineTo(this.x, this.y - this.size * 0.2);
                    break;
                case 'dasher':
                    ctx.moveTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x - this.size, this.y - this.size);
                    ctx.lineTo(this.x, this.y - this.size * 0.5);
                    ctx.lineTo(this.x + this.size, this.y - this.size);
                    break;
                case 'weaver':
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const radius = i % 2 === 0 ? this.size : this.size * 0.5;
                        const xPos = this.x + radius * Math.cos(angle);
                        const yPos = this.y + radius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
                    }
                    break;
                case 'kamikaze':
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    break;
                case 'bulwark':
                    ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                    break;
                case 'sentinel':
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    break;
                case 'barrier':
                    ctx.moveTo(this.x - this.size, this.y - this.size);
                    ctx.lineTo(this.x + this.size, this.y - this.size);
                    ctx.lineTo(this.x + this.size * 0.7, this.y + this.size);
                    ctx.lineTo(this.x - this.size * 0.7, this.y + this.size);
                    break;
                case 'splitter':
                    // ÏÇ¨Ïù¥Î≤ÑÌéëÌÅ¨ Îã§Ïù¥ÏïÑÎ™¨Îìú ÌòïÌÉú
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x + this.size * 0.7, this.y);
                    ctx.lineTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x - this.size * 0.7, this.y);
                    // ÎÇ¥Î∂Ä ÏΩîÏñ¥
                    ctx.fill();
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x + this.size * 0.7, this.y);
                    ctx.lineTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x - this.size * 0.7, this.y);
                    break;
                case 'summoner':
                    // ÏÇ¨Ïù¥Î≤ÑÌéëÌÅ¨ Ïú°Í∞ÅÌòï
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const xPos = this.x + this.size * Math.cos(angle);
                        const yPos = this.y + this.size * Math.sin(angle);
                        if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
                    }
                    // ÎÇ¥Î∂Ä ÏõêÌòï Ìå®ÌÑ¥Îì§
                    ctx.fill();
                    ctx.strokeStyle = '#ff80ff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, (this.size * 0.3) + i * 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = this.isElite ? '#FFD700' : '#FFF';
                    ctx.lineWidth = this.isElite ? 3 : 1.5;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const xPos = this.x + this.size * Math.cos(angle);
                        const yPos = this.y + this.size * Math.sin(angle);
                        if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
                    }
                    break;
                case 'boss':
                     for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const radius = i % 2 === 0 ? this.size : this.size * 0.7;
                        const xPos = this.x + radius * Math.cos(angle);
                        const yPos = this.y + radius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(xPos, yPos); else ctx.lineTo(xPos, yPos);
                    }
                    break;
                default:
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    break;
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;

            if (this.type === 'barrier' && this.shieldHealth > 0) { ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(this.x - this.size, this.y + this.size); ctx.lineTo(this.x + this.size, this.y + this.size); ctx.stroke(); }
            if(this.type === 'boss') { 
                const barWidth = canvas.width * 0.8, barX = (canvas.width - barWidth) / 2; 
                ctx.fillStyle = 'rgba(50,50,50,0.8)'; 
                ctx.fillRect(barX, 10, barWidth, 10); 
                ctx.fillStyle = this.color; 
                ctx.fillRect(barX, 10, barWidth * (this.health / this.maxHealth), 10);
                
                // Î≤àÍ∞ú Í≥µÍ≤© Í≤ΩÍ≥† ÌëúÏãú
                this.lightningTargets.forEach(target => {
                    if (target.timer > 0.5) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.globalAlpha = 0.7;
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(target.x, 0);
                        ctx.lineTo(target.x, canvas.height);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.globalAlpha = 1.0;
                    }
                });
                
                // Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº Í∑∏Î¶¨Í∏∞
                this.guidedMissiles.forEach(missile => missile.draw(ctx));
            }
            if (this.type === 'sentinel' && this.laserCharge > this.laserMaxCharge - 1) { ctx.strokeStyle = 'red'; ctx.globalAlpha = 0.5; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(player.x, player.y); ctx.stroke(); ctx.globalAlpha = 1.0; }
        }
        shoot() {
            if (!player) return; const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x) * 180 / Math.PI;
            switch(this.type) {
                case 'bulwark': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed * 0.5, 'enemy', {size: 15})); this.shootTimer = 4.0; break;
                case 'sentinel': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed * 4, 'enemy', {isPiercing: true, width: 4, height: 20})); break;
                case 'dasher': case 'barrier': break;
                case 'weaver': bullets.push(new Bullet(this.x, this.y, this.angle * 180 / Math.PI, this.bulletSpeed, 'enemy')); this.shootTimer = 1.5; break;
                case 'basic': bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed, 'enemy')); this.shootTimer = 2.5; break;
                case 'shooter': for (let i = -1; i <= 1; i++) { bullets.push(new Bullet(this.x, this.y, angleToPlayer + i * 15, this.bulletSpeed * 0.8, 'enemy')); } this.shootTimer = 2.0; break;
                case 'splitter': bullets.push(new Bullet(this.x, this.y, angleToPlayer + (Math.random() - 0.5) * 30, this.bulletSpeed * 0.9, 'enemy')); this.shootTimer = 2.5; break;
                case 'summoner': for (let i = 0; i < 5; i++) { bullets.push(new Bullet(this.x, this.y, angleToPlayer + (i - 2) * 20, this.bulletSpeed * 0.7, 'enemy')); } this.shootTimer = 3.0; break;
                case 'boss':
                    const pTimer = this.patternTimer;
                    switch(this.pattern) {
                        case 'crossfire': 
                            for(let i=0; i<2; i++) bullets.push(new Bullet(this.x, this.y, angleToPlayer + i * 20 - 10, this.bulletSpeed * 1.1, 'enemy')); 
                            this.shootTimer = 0.3; 
                            break;
                        case 'weave': 
                            for (let i = 0; i < 5; i++) bullets.push(new Bullet(canvas.width * (pTimer/this.patternDuration) + i*20 - 40, -20, 90, this.bulletSpeed * 0.5, 'enemy')); 
                            this.shootTimer = 0.1; 
                            break;
                        case 'sunburst': 
                            for (let i = 0; i < 36; i++) bullets.push(new Bullet(this.x, this.y, i * 10 + pTimer * 20, this.bulletSpeed, 'enemy')); 
                            this.shootTimer = 1.5; 
                            break;
                        case 'ricochet': 
                            bullets.push(new Bullet(this.x, this.y, pTimer * 40, this.bulletSpeed, 'enemy', {bouncesLeft: 2})); 
                            this.shootTimer = 0.2; 
                            break;
                        case 'spiral':
                            bullets.push(new Bullet(this.x, this.y, pTimer * 50, this.bulletSpeed * 0.9, 'enemy')); 
                            bullets.push(new Bullet(this.x, this.y, -pTimer * 50, this.bulletSpeed * 0.9, 'enemy')); 
                            this.shootTimer = 0.05; 
                            break;
                        case 'spawn_minions':
                            for(let i=0; i<3; i++) {
                                enemies.push(new Enemy(this.x + (i-1)*50, this.y, 'dasher'));
                            }
                            this.shootTimer = 3.0; // Spawn another wave in 3 seconds
                            break;
                        case 'desperate': 
                            bullets.push(new Bullet(this.x, this.y, angleToPlayer + Math.random()*40-20, this.bulletSpeed * 1.5, 'enemy')); 
                            if(Math.random() < 0.1) bullets.push(new Bullet(this.x, this.y, Math.random()*360, this.bulletSpeed * 0.8, 'enemy')); 
                            this.shootTimer = 0.1; 
                            break;
                        case 'tidal_wave':
                            // ÌååÎèÑ: ÌïúÏ™ΩÏóêÏÑú Îã§Î•∏Ï™ΩÏúºÎ°ú ÏàúÏ∞® Î∞úÏÇ¨
                            const waveX = this.waveDirection > 0 ? (pTimer / this.patternDuration) * canvas.width : canvas.width - (pTimer / this.patternDuration) * canvas.width;
                            for (let i = 0; i < 3; i++) {
                                bullets.push(new Bullet(waveX + (i-1)*30, this.y + 20, 90 + (i-1)*10, this.bulletSpeed * 0.8, 'enemy'));
                            }
                            if (pTimer > this.patternDuration * 0.9) this.waveDirection *= -1;
                            this.shootTimer = 0.15;
                            break;
                        case 'lightning_strike':
                            // Î≤àÍ∞ú: ÌîåÎ†àÏù¥Ïñ¥ ÏòàÏÉÅ ÏúÑÏπòÏóê Í≤ΩÍ≥† ÌõÑ Î†àÏù¥Ï†Ä Î∞úÏÇ¨
                            if (pTimer < 1) {
                                const predictedX = player.x + player.vx * 0.5;
                                this.lightningTargets.push({
                                    x: Math.max(20, Math.min(canvas.width-20, predictedX)),
                                    timer: 1.5,
                                    warned: false
                                });
                                this.shootTimer = 1.0;
                            } else {
                                this.lightningTargets.forEach(target => {
                                    if (target.timer < 0.5 && !target.fired) {
                                        bullets.push(new Bullet(target.x, -10, 90, this.bulletSpeed * 3, 'enemy', {isPiercing: true, width: 8, height: canvas.height}));
                                        target.fired = true;
                                    }
                                });
                                this.shootTimer = 0.3;
                            }
                            break;
                        case 'orbital_strike':
                            // Í∂§ÎèÑ ÌÉÄÍ≤©: Î≥¥Ïä§ Ï£ºÎ≥Ä 3Í∞ú Í∂§ÎèÑÏóêÏÑú ÌöåÏ†ÑÌïòÎ©∞ Î∞úÏÇ¨
                            for (let orbit = 0; orbit < 3; orbit++) {
                                const orbitRadius = 80 + orbit * 30;
                                const orbitSpeed = (orbit + 1) * 0.5;
                                const angle = this.orbitalAngle * orbitSpeed + orbit * 120;
                                const orbitX = this.x + Math.cos(angle * Math.PI / 180) * orbitRadius;
                                const orbitY = this.y + Math.sin(angle * Math.PI / 180) * orbitRadius;
                                bullets.push(new Bullet(orbitX, orbitY, angle + 90, this.bulletSpeed * 0.6, 'enemy'));
                            }
                            this.shootTimer = 0.2;
                            break;
                        case 'guided_missiles':
                            // Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº: ÌîåÎ†àÏù¥Ïñ¥Î•º Ï∂îÏ†ÅÌïòÎã§Í∞Ä Í∞ÄÍπåÏù¥ Í∞ÄÎ©¥ ÏßÅÏßÑ
                            if (this.guidedMissiles.length < 4) {
                                this.guidedMissiles.push(new GuidedMissile(this.x + (Math.random()-0.5)*60, this.y + 30, this.bulletSpeed * 0.4));
                            }
                            this.shootTimer = 1.5;
                            break;
                        case 'area_blast':
                            // Î≤îÏúÑÍ≥µÍ≤©: ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥ÄÏóê Ìè≠Î∞ú ÏßÄÏó≠ ÏÉùÏÑ±
                            const blastX = player.x + (Math.random()-0.5)*100;
                            const blastY = player.y + (Math.random()-0.5)*100;
                            // Í≤ΩÍ≥† Ïù¥ÌéôÌä∏ ÏÉùÏÑ±
                            particles.push(new Particle(blastX, blastY, '#ff4444', 30, {
                                type: 'warning',
                                lifespan: 1.5,
                                fade: true
                            }));
                            // 1.5Ï¥à ÌõÑ Ìè≠Î∞ú
                            setTimeout(() => {
                                for (let i = 0; i < 20; i++) {
                                    const angle = (i / 20) * 360;
                                    bullets.push(new Bullet(blastX, blastY, angle, this.bulletSpeed * 0.8, 'enemy'));
                                }
                                createExplosion(blastX, blastY, '#ff4444', 15);
                            }, 1500);
                            this.shootTimer = 2.0;
                            break;
                        default: 
                            bullets.push(new Bullet(this.x, this.y, angleToPlayer, this.bulletSpeed, 'enemy')); 
                            this.shootTimer = 0.5; 
                            break;
                    } 
                    break;
            }
        }
        takeDamage(damage, fromBehind = false) {
            if (this.type === 'barrier' && this.shieldHealth > 0 && !fromBehind) { this.shieldHealth -= damage; if(this.shieldHealth <= 0) createExplosion(this.x, this.y + this.size, '#00ffff', 20); return; }
            this.health -= damage;
            if (this.health <= 0) {
                // Î∂ÑÏó¥Ï≤¥ ÌäπÏàò Îä•Î†•: Ï£ΩÏùÑ Îïå Î∂ÑÏó¥
                if (this.type === 'splitter' && !this.hasSplit) {
                    this.hasSplit = true;
                    for (let i = 0; i < 3; i++) {
                        const angle = (i - 1) * 60;
                        const splitX = this.x + Math.cos(angle * Math.PI / 180) * 30;
                        const splitY = this.y + Math.sin(angle * Math.PI / 180) * 30;
                        const fragment = new Enemy(splitX, splitY, 'basic');
                        fragment.size = 10;
                        fragment.health = 8;
                        fragment.color = '#ff3300';
                        fragment.speed = 200;
                        fragment.scoreValue = 50;
                        fragment.isSplitterFragment = true; // Î∂ÑÏó¥Îêú Ï°∞Í∞ÅÏûÑÏùÑ ÌëúÏãú
                        enemies.push(fragment);
                    }
                    // Î∂ÑÏó¥ Ïù¥ÌéôÌä∏
                    for (let i = 0; i < 15; i++) {
                        particles.push(new Particle(this.x, this.y, '#ff6600', 8, {
                            type: 'spark',
                            speed: 200,
                            lifespan: 0.8
                        }));
                    }
                }
                
                if (player) { 
                    playerStats.totalKills++;
                    // ÏÉàÎ°úÏö¥ Ï†Å ÌÉÄÏûÖÎ≥Ñ ÌÇ¨ Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                    if (this.type === 'splitter') playerStats.splitterKills++;
                    else if (this.type === 'summoner') playerStats.summonerKills++;
                }
                const scoreBonus = selectedCharacterId === 'blade' ? 1.5 : 1;
                score += this.scoreValue * Math.floor(scoreMultiplier) * scoreBonus;
                if (selectedCharacterId === 'pulse' && player) player.addChronoGauge(0.5);
                if (this.type === 'boss') bossKillBonus += 250;
                
                if (player && player.skinData.killEffect === 'firework') { createFireworkExplosion(this.x, this.y, player.attackColor, player.accentColor);
                } else { createExplosion(this.x, this.y, this.color, 20); }
                playSound('explosion');
                const dropChance = this.type === 'boss' ? 1.0 : 0.08;
                if (Math.random() < dropChance) { let itemType = 'P'; const rand = Math.random(); if (rand < 0.25) itemType = 'B'; else if (rand < 0.5) itemType = 'C'; powerUps.push(new PowerUpItem(this.x, this.y, itemType)); }
                else if (Math.random() < 0.015) { powerUps.push(new PowerUpItem(this.x, this.y, 'S')); }
            }
        }
        
        summonMinion() {
            if (this.minionsSpawned >= this.maxMinions) return;
            const minionX = this.x + (Math.random() - 0.5) * 80;
            const minionY = this.y + 30;
            const minion = new Enemy(minionX, minionY, 'basic');
            minion.size = 8;
            minion.health = 5;
            minion.color = '#cc66ff';
            minion.speed = 120;
            minion.scoreValue = 75;
            minion.bulletSpeed *= 0.8;
            enemies.push(minion);
            this.minionsSpawned++;
            
            // ÏÜåÌôò Ïù¥ÌéôÌä∏
            for (let i = 0; i < 10; i++) {
                particles.push(new Particle(minionX, minionY, '#b300ff', 6, {
                    type: 'nova',
                    secondaryColor: '#ff80ff',
                    speed: 100,
                    lifespan: 0.6
                }));
            }
        }
    }
    
    class GuidedMissile {
        constructor(x, y, speed) {
            this.x = x;
            this.y = y;
            this.speed = speed;
            this.size = 8;
            this.active = true;
            this.tracking = true;
            this.vx = 0;
            this.vy = speed;
            this.color = '#ff6600';
            this.trailParticles = [];
        }
        
        update(deltaTime) {
            if (!this.active) return;
            
            if (this.tracking && player) {
                const distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);
                
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í∞ÄÍπåÏõåÏßÄÎ©¥ ÏßÅÏßÑ Î™®ÎìúÎ°ú Ï†ÑÌôò
                if (distToPlayer < 60) {
                    this.tracking = false;
                } else {
                    // ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÏ†Å
                    const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                    this.vx = Math.cos(angleToPlayer) * this.speed;
                    this.vy = Math.sin(angleToPlayer) * this.speed;
                }
            }
            
            // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            this.x += this.vx * deltaTime * gameSpeed;
            this.y += this.vy * deltaTime * gameSpeed;
            
            // Ìä∏Î†àÏùº Ïù¥ÌéôÌä∏
            if (Math.random() < 0.3) {
                this.trailParticles.push(new Particle(this.x, this.y, this.color, 4, {
                    type: 'trail',
                    lifespan: 0.5,
                    fade: true
                }));
            }
            
            // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï†úÍ±∞
            if (this.x < -20 || this.x > canvas.width + 20 || this.y > canvas.height + 20) {
                this.active = false;
            }
            
            // ÌîåÎ†àÏù¥Ïñ¥ Ï∂©Îèå Í≤ÄÏÇ¨
            if (player && Math.hypot(this.x - player.x, this.y - player.y) < this.size + player.hitboxSize) {
                player.takeHit();
                this.active = false;
                createExplosion(this.x, this.y, this.color, 8);
            }
        }
        
        draw(ctx) {
            if (!this.active) return;
            
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // ÎØ∏ÏÇ¨Ïùº Î™∏Ï≤¥
            ctx.fillStyle = this.color;
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(-this.size/2, this.size);
            ctx.lineTo(this.size/2, this.size);
            ctx.closePath();
            ctx.fill();
            
            // Ï∂îÏ†Å Î™®Îìú ÌëúÏãú
            if (this.tracking) {
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }
    
    class Particle {
        constructor(x, y, color, size, options = {}) { this.x = x; this.y = y; this.color = color; this.size = Math.random() * size + 2; this.lifespan = options.lifespan || 1; this.initialLifespan = this.lifespan; this.options = options; this.vx = (Math.random() - 0.5) * (options.speed || 150); this.vy = (Math.random() - 0.5) * (options.speed || 150); if (options.type === 'spark') { const angle = Math.random() * Math.PI * 2; this.vx = Math.cos(angle) * 300; this.vy = Math.sin(angle) * 300; } if (options.type === 'trail') { this.vx = 0; this.vy = 0; } }
        update(deltaTime) { this.x += this.vx * deltaTime * gameSpeed; this.y += this.vy * deltaTime * gameSpeed; this.lifespan -= deltaTime; if(this.options.type === 'spark' || this.options.type === 'nova') { this.vx *= 0.9; this.vy *= 0.9; } }
        draw(ctx) { 
            ctx.globalAlpha = this.options.fade ? this.lifespan / this.initialLifespan : this.lifespan > 0.5 ? 1 : this.lifespan * 2; 
            ctx.fillStyle = (this.options.type === 'nova' && Math.random() < 0.5) ? this.options.secondaryColor : this.color; 
            ctx.beginPath(); 
            if (this.options.type === 'warp') { 
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size); 
            } else if (this.options.type === 'warning') {
                // Í≤ΩÍ≥† Ïù¥ÌéôÌä∏: ÍπúÎπ°Ïù¥Îäî Ïõê
                const alpha = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            } else { 
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); 
                ctx.fill();
            } 
            ctx.globalAlpha = 1; 
        }
    }
    class PowerUpItem {
        constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.size = 12; this.speed = 80; this.angle = 0; switch(type) { case 'P': this.color = colors.powerupP; break; case 'B': this.color = colors.powerupB; break; case 'C': this.color = colors.powerupC; break; case 'S': this.color = colors.powerupS; break; } }
        update(deltaTime) { this.angle += deltaTime * 5; if (upgrades.magnet.level > 0 && player) { const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angleToPlayer) * 300 * deltaTime; this.y += Math.sin(angleToPlayer) * 300 * deltaTime; } else { this.y += this.speed * deltaTime * gameSpeed; } }
        draw(ctx) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.color; ctx.shadowColor = this.color; ctx.shadowBlur = 10; ctx.beginPath(); ctx.rect(-this.size, -this.size, this.size*2, this.size*2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 12px "Press Start 2P"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const symbol = this.type === 'S' ? 'üíé' : this.type; ctx.fillText(symbol, 0, 1); ctx.restore(); }
    }
    class Turret {
        constructor(x, y, power, color) {
            this.x = x; this.y = y; this.power = power; this.size = 15;
            this.lifespan = 8 + power * 0.5;
            this.shootCooldown = 0;
            this.color = color || SKIN_DATA.sentry.default.shipColor;
        }
        update(deltaTime) {
            this.lifespan -= deltaTime * gameSpeed;
            this.shootCooldown -= deltaTime * gameSpeed;
            if (this.shootCooldown <= 0) this.shoot();
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.globalAlpha = this.lifespan % 1;
            ctx.beginPath();
            ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        shoot() {
            this.shootCooldown = 0.4 / (1 + this.power * 0.2); // Nerfed fire rate (0.2 -> 0.4, 0.3 -> 0.2)
            
            // Enhanced bullets that clear enemy projectiles
            for (let i = 0; i < 3 + this.power; i++) {
                let closestEnemy = null, minDist = Infinity;
                for (const enemy of enemies) {
                    const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                    if (dist < minDist) { minDist = dist; closestEnemy = enemy; }
                }
                if (closestEnemy) {
                    const angleToTarget = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x) * 180 / Math.PI + (Math.random() - 0.5) * 20;
                    bullets.push(new Bullet(this.x, this.y, angleToTarget, 800, 'player', {
                        color: this.color, 
                        isPiercing: true, 
                        width: 8, 
                        height: 15,
                        clearsBullets: true // Special property for turret bullets
                    }));
                }
            }
        }
    }
    class Ally {
        constructor(x, y, power, color) {
            this.x = x; this.y = y; this.power = power; this.size = 8;
            this.lifespan = 10 + power;
            this.shootCooldown = 0;
            this.color = color || SKIN_DATA.conjuror.default.shipColor;
            this.speed = 200;
        }
        update(deltaTime) {
            this.lifespan -= deltaTime * gameSpeed;
            this.shootCooldown -= deltaTime * gameSpeed;
            if (player) {
                // Follow player and focus fire
                const targetX = player.x + (this.x > player.x ? 40 : -40);
                const targetY = player.y + 20;
                const dx = targetX - this.x, dy = targetY - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 1) {
                    this.x += (dx / dist) * this.speed * deltaTime * gameSpeed;
                    this.y += (dy / dist) * this.speed * deltaTime * gameSpeed;
                }
            }
            if (this.shootCooldown <= 0) this.shoot();
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        shoot() {
            this.shootCooldown = 0.1; // Very fast interception rate
            
            // Prioritize intercepting enemy bullets over attacking enemies
            let targetBullet = null;
            let minBulletDist = Infinity;
            for (const bullet of bullets) {
                if (bullet.owner === 'enemy') {
                    const dist = Math.hypot(this.x - bullet.x, this.y - bullet.y);
                    if (dist < minBulletDist && dist < 200) { // Only target nearby bullets
                        minBulletDist = dist;
                        targetBullet = bullet;
                    }
                }
            }
            
            if (targetBullet) {
                const angleToTarget = Math.atan2(targetBullet.y - this.y, targetBullet.x - this.x) * 180 / Math.PI;
                bullets.push(new Bullet(this.x, this.y, angleToTarget, 900, 'player', {
                    size: 4, 
                    color: this.color,
                    isInterceptor: true // Special property for ally bullets
                }));
            } else if (enemies.length > 0) {
                // If no bullets to intercept, attack enemies
                let target = enemies[0];
                if (player) {
                    let closestDist = Infinity;
                    enemies.forEach(e => {
                        const dist = Math.hypot(player.x - e.x, player.y - e.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = e;
                        }
                    });
                }
                const angleToTarget = Math.atan2(target.y - this.y, target.x - this.x) * 180 / Math.PI;
                bullets.push(new Bullet(this.x, this.y, angleToTarget, 700, 'player', {size: 5, color: this.color}));
            }
        }
    }

    // --- 4. ÌïµÏã¨ Î°úÏßÅ Î∞è Í≤åÏûÑ Î£®ÌîÑ ---
    const inputHandler = { 
        keys: {}, 
        touch: { x: 0, y: 0, active: false, chronoActive: false, bombPressed: false }, 
        setup() { 
            document.querySelectorAll('.mobile-control').forEach(el => el.style.display = 'none'); 
            if (controlMode === 'touch') { 
                document.querySelectorAll('.mobile-control').forEach(el => el.style.display = 'flex'); 
                canvas.addEventListener('touchstart', this.handleTouch.bind(this)); 
                canvas.addEventListener('touchmove', this.handleTouch.bind(this)); 
                canvas.addEventListener('touchend', e => { this.touch.active = false; }); 
                mobileChronoButton.addEventListener('touchstart', e => { e.preventDefault(); this.touch.chronoActive = true; mobileChronoButton.classList.add('active'); }); 
                mobileChronoButton.addEventListener('touchend', e => { e.preventDefault(); this.touch.chronoActive = false; mobileChronoButton.classList.remove('active'); }); 
                mobileBombButton.addEventListener('touchstart', e => { e.preventDefault(); this.touch.bombPressed = true; mobileBombButton.classList.add('active'); }); 
                mobileBombButton.addEventListener('touchend', e => { e.preventDefault(); mobileBombButton.classList.remove('active'); }); 
            } else { 
                document.addEventListener('keydown', e => { this.keys[e.key] = true; }); 
                document.addEventListener('keyup', e => { this.keys[e.key] = false; }); 
            } 
        }, 
        handleTouch(e) { 
            e.preventDefault(); 
            this.touch.active = true; 
            const rect = canvas.getBoundingClientRect(); 
            this.touch.x = e.touches[0].clientX - rect.left; 
            this.touch.y = e.touches[0].clientY - rect.top; 
        } 
    };
    function checkCollisions() {
        // Player bullets vs Enemies and Enemy bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            if (!b || b.owner !== 'player') continue;
            const damage = 10 + player.power;
            
            // Special handling for turret bullets that clear enemy bullets
            if (b.special.clearsBullets) {
                for (let k = bullets.length - 1; k >= 0; k--) {
                    const enemyBullet = bullets[k];
                    if (enemyBullet.owner === 'enemy' && Math.hypot(b.x - enemyBullet.x, b.y - enemyBullet.y) < 20) {
                        createExplosion(enemyBullet.x, enemyBullet.y, b.color, 2);
                        bullets.splice(k, 1);
                        if (k < i) i--; // Adjust index
                    }
                }
            }
            
            // Ally interceptor bullets vs enemy bullets
            if (b.special.isInterceptor) {
                for (let k = bullets.length - 1; k >= 0; k--) {
                    const enemyBullet = bullets[k];
                    if (enemyBullet.owner === 'enemy' && Math.hypot(b.x - enemyBullet.x, b.y - enemyBullet.y) < 15) {
                        createExplosion(enemyBullet.x, enemyBullet.y, b.color, 3);
                        bullets.splice(k, 1);
                        bullets.splice(i, 1);
                        if (k < i) i--;
                        break;
                    }
                }
                continue;
            }
            
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                if (!e) continue;

                if (b.special.isLaser) {
                    const laserRect = { x: b.x - b.width / 2, y: 0, width: b.width, height: canvas.height };
                    const closestX = Math.max(laserRect.x, Math.min(e.x, laserRect.x + laserRect.width));
                    const closestY = Math.max(laserRect.y, Math.min(e.y, laserRect.y + laserRect.height));
                    const distanceSquared = (e.x - closestX)**2 + (e.y - closestY)**2;
                    if (distanceSquared < (e.size * e.size)) {
                        e.takeDamage(damage * 1.5, b.y < e.y); // Continuous damage, slightly boosted
                    }
                } else {
                    const dist = Math.hypot(b.x - e.x, b.y - e.y);
                    const hitRadius = b.special.isNebulaOrb ? b.size : (b.special.isWave ? b.size : (b.size || 5));
                    if (dist < e.size + hitRadius) {
                        if (b.special.isPiercing || b.special.isNebulaOrb || b.special.isVortex || b.special.isPrism) {
                            if (b.hitEnemies.has(e)) continue;
                            b.hitEnemies.add(e);
                        }
                        e.takeDamage(damage, b.y < e.y);
                        
                        // Prism splitting effect
                        if (b.special.isPrism && b.special.splitsLeft > 0) {
                            for(let j = 0; j < 3; j++) {
                                const splitAngle = Math.atan2(e.y - b.y, e.x - b.x) + (j - 1) * 45;
                                bullets.push(new Bullet(e.x, e.y, splitAngle * 180/Math.PI, 600, 'player', {
                                    color: b.color,
                                    accentColor: b.special.accentColor,
                                    damage: damage * 0.7,
                                    size: b.size * 0.8,
                                    splitsLeft: b.special.splitsLeft - 1,
                                    isPrism: true
                                }));
                            }
                            if (player) player.prismChain++;
                        }
                        
                        // Vortex kill streak
                        if (b.special.isVortex && e.health <= damage && player) {
                            player.killStreak++;
                        }
                        
                        if (!b.special.isPiercing && !b.special.isWave && !b.special.isNebulaOrb && !b.special.isVortex && !b.special.isPrism) {
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        if (player && player.orbiters) { for (const orb of player.orbiters) { const damage = (5 + player.power) * 0.2; for (let j = enemies.length - 1; j >= 0; j--) { const e = enemies[j]; if (!e) continue; const dist = Math.hypot(orb.x - e.x, orb.y - e.y); if (dist < e.size + orb.size) { e.takeDamage(damage); } } } }
        
        // Enemy bullets vs Player
        if (player && !player.isInvincible) { for (let i = bullets.length - 1; i >= 0; i--) { const b = bullets[i]; if (!b || b.owner !== 'enemy') continue; if (player.isShielding) { const shieldDist = Math.hypot(b.x - player.x, b.y - player.y); if (shieldDist < 30 + b.size) { player.shieldPower++; createExplosion(b.x, b.y, player.color, 3); bullets.splice(i, 1); continue; } } if (!b.grazed) { const grazeDist = Math.hypot(b.x - player.x, b.y - player.y); if (grazeDist < player.grazeRadius + b.size) { b.grazed = true; scoreMultiplier += 0.1; player.addChronoGauge(3); playSound('graze'); playerStats.totalGraze++; } } const hitDist = Math.hypot(b.x - player.x, b.y - player.y); if (hitDist < player.hitboxSize + b.size) { player.takeHit(); bullets.splice(i, 1); scoreMultiplier = 1; break; } } }
        
        // Powerups vs Player
        for (let i = powerUps.length - 1; i >= 0; i--) { const p = powerUps[i]; if (player) { const dist = Math.hypot(p.x - player.x, p.y - player.y); if (dist < player.size + p.size + (upgrades.magnet.level > 0 ? 50 : 0)) { playSound('itemGet', 1.0); createExplosion(p.x, p.y, p.color, 10); switch(p.type) { case 'P': player.power++; break; case 'B': player.bombs = Math.min(5, player.bombs + 1); break; case 'C': player.addChronoGauge(50); break; case 'S': const earned = 50 + Math.floor(Math.random() * 51); chronoShards += earned; playerStats.totalShardsEarned += earned; updateAllUI(); break; } powerUps.splice(i, 1); } } }
    }
    function spawnEnemies(deltaTime) { waveTimer += deltaTime; const waveDuration = 45; if (waveTimer > waveDuration) { wave++; waveTimer = 0; waveClearBonus += 10; if (wave > 0 && wave % 3 === 0 && !enemies.some(e => e.type === 'boss')) { enemies.push(new Enemy(canvas.width / 2, -50, 'boss')); return; } } if (!enemies.some(e => e.type === 'boss')) { const spawnRate = 0.03 * (1 + wave * 0.20) * gameSpeed; if (Math.random() < spawnRate) { const x = Math.random() * canvas.width; const rand = Math.random(); let type = 'basic'; if (wave >= 12 && rand < 0.08) type = 'summoner'; else if (wave >= 10 && rand < 0.15) type = 'splitter'; else if (wave >= 8 && rand < 0.22) type = 'sentinel'; else if (wave >= 6 && rand < 0.32) type = 'bulwark'; else if (wave >= 4 && rand < 0.42) type = 'barrier'; else if (wave > 3 && rand < 0.57) type = 'kamikaze'; else if (wave > 2 && rand < 0.72) type = 'weaver'; else if (wave > 1 && rand < 0.85) type = 'dasher'; else if (rand < 0.95) type = 'shooter'; enemies.push(new Enemy(x, -20, type)); } } }
    function createExplosion(x, y, color, count, options) { for (let i = 0; i < count; i++) { particles.push(new Particle(x, y, color, 5, options)); } }
    function createFireworkExplosion(x, y, color1, color2, count = 30) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 200 + 50; const particleColor = Math.random() > 0.5 ? color1 : color2; particles.push(new Particle(x, y, particleColor, 4, { speed: speed, lifespan: 1.5, fade: true, type: 'spark'})); } }
    let screenFlashTimer = 0; function createScreenFlash() { screenFlashTimer = 0.2; }
    
    function update(deltaTime) {
        if (gameState !== 'playing' || !player) return;
        lowHealthPulse += deltaTime * 5;
        if (screenShake > 0) screenShake = Math.max(0, screenShake - 30 * deltaTime);
        if (screenFlashTimer > 0) screenFlashTimer -= deltaTime;
        player.update(deltaTime, inputHandler);
        enemies.forEach(e => e.update(deltaTime));
        bullets.forEach(b => b.update(deltaTime));
        particles.forEach(p => p.update(deltaTime));
        powerUps.forEach(p => p.update(deltaTime));
        turrets.forEach(t => t.update(deltaTime));
        allies.forEach(a => a.update(deltaTime));
        checkCollisions();
        spawnEnemies(deltaTime);
        bullets = bullets.filter(b => b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50 && (!b.special.lifespan || b.special.lifespan > 0));
        enemies = enemies.filter(e => e.health > 0);
        particles = particles.filter(p => p.lifespan > 0);
        powerUps = powerUps.filter(p => p.y < canvas.height + 20);
        turrets = turrets.filter(t => t.lifespan > 0);
        allies = allies.filter(a => a.lifespan > 0);
        if (scoreMultiplier > 1) { scoreMultiplier -= 0.05 * deltaTime; if (scoreMultiplier < 1) scoreMultiplier = 1; }
        backgroundStars.forEach(s => { s.y += s.speed * deltaTime * gameSpeed; if (s.y > canvas.height) { s.y = 0; s.x = Math.random() * canvas.width; } });
    }
    function draw() {
        ctx.save();
        if (screenShake > 0) { const shakeX = (Math.random() - 0.5) * screenShake; const shakeY = (Math.random() - 0.5) * screenShake; ctx.translate(shakeX, shakeY); }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        backgroundStars.forEach(s => { ctx.globalAlpha = s.opacity; ctx.fillRect(s.x, s.y, s.size, s.size); });
        ctx.globalAlpha = 1;
        if (screenFlashTimer > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${screenFlashTimer * 4})`; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        if (player && player.skinRarity === 4 && gameSpeed < 1) { const grad = ctx.createRadialGradient(player.x, player.y, 50, player.x, player.y, canvas.width/2); grad.addColorStop(0, player.accentColor + '00'); grad.addColorStop(1, player.accentColor + '40'); ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width, canvas.height); }
        if (gameState === 'playing' || gameState === 'gameOver') {
            powerUps.forEach(p => p.draw(ctx));
            turrets.forEach(t => t.draw(ctx));
            allies.forEach(a => a.draw(ctx));
            if (player) { player.draw(ctx); if (player.orbiters) player.orbiters.forEach(o => o.draw(ctx)); }
            enemies.forEach(e => e.draw(ctx));
            bullets.forEach(b => b.draw(ctx));
            particles.forEach(p => p.draw(ctx));
        }
        if (player && player.lives <= 1 && !player.isInvincible) { const alpha = 0.3 + Math.sin(lowHealthPulse) * 0.2; ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        ctx.restore();
        updateInGameUI();
    }
    function updateInGameUI() { scoreEl.textContent = `SCORE: ${Math.floor(score)}`; highScoreEl.textContent = `HIGH: ${Math.floor(highScore)}`; if (player) { let lifeText = ''; for(let i=0; i<player.lives; i++) lifeText += '‚ô•'; lifeInfoEl.textContent = lifeText; let specialText = ''; switch(selectedCharacterId) { case 'rift': specialText = `BLINK ${player.blinkCooldown > 0 ? Math.ceil(player.blinkCooldown) : 'RDY'}`; break; case 'phase': specialText = `DASH ${player.dashCooldown > 0 ? Math.ceil(player.dashCooldown) : 'RDY'}`; break; case 'echo': specialText = `Ìå®ÎßÅ ${player.parryCooldown > 0 ? Math.ceil(player.parryCooldown) : 'RDY'}`; break; case 'aegis': specialText = `SHIELD ${player.isShielding ? 'ON' : 'OFF'}`; break; case 'sentry': specialText = `TURRET ${player.turretCooldown > 0 ? Math.ceil(player.turretCooldown) : 'RDY'}`; break; case 'conjuror': specialText = `SUMMON ${player.summonCooldown > 0 ? Math.ceil(player.summonCooldown) : 'RDY'}`; break; default: for(let i=0; i<player.bombs; i++) specialText += '‚òÖ'; break; } bombInfoEl.textContent = specialText; chronoGaugeBarEl.style.width = `${player.chronoGauge}%`; } }
    function gameLoop(timestamp) { if (!lastTime) lastTime = timestamp; const deltaTime = Math.min(0.1, (timestamp - lastTime) / 1000); lastTime = timestamp; if (gameState === 'playing') update(deltaTime); draw(); animationFrameId = requestAnimationFrame(gameLoop); }
    function gameOver() {
        gameState = 'gameOver';
        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        const scoreToShards = Math.floor(score / 500);
        const totalEarned = scoreToShards + waveClearBonus + bossKillBonus;
        chronoShards += totalEarned;
        playerStats.totalShardsEarned += totalEarned;
        playerStats.gamesPlayed++;
        playerStats.maxScore = Math.max(playerStats.maxScore, Math.floor(score));
        playerStats.maxWave = Math.max(playerStats.maxWave, wave);

        if (score > highScore) highScore = score;
        const charData = characters[selectedCharacterId];
        if(score > charData.highScore) charData.highScore = Math.floor(score);
        if(!charData.skins.mythic.unlocked && charData.highScore >= 1000000) { charData.skins.mythic.unlocked = true; setTimeout(() => alert(`üèÜ ${charData.name} Ïã†Ìôî Ïä§ÌÇ® Ìï¥Í∏à! üèÜ\n1,000,000Ï†ê Îã¨ÏÑ±ÏùÑ Ï∂ïÌïòÌï©ÎãàÎã§!`), 500); }
        
        checkUnlocks();
        saveData();

        finalScoreEl.textContent = `FINAL SCORE: ${Math.floor(score)}`;
        shardsEarnedEl.innerHTML = `üíé +${scoreToShards} (Score)<br>üíé +${waveClearBonus} (Wave)<br>üíé +${bossKillBonus} (Boss)<br>TOTAL: üíé +${totalEarned}`;
        shardsEarnedEl.classList.add('animate');
        setTimeout(() => shardsEarnedEl.classList.remove('animate'), 1000);
        draw();
        gameOverScreen.style.display = 'flex';
    }
    function resetGame() { score = 0; scoreMultiplier = 1; wave = 0; waveTimer = 0; gameSpeed = 1; waveClearBonus = 0; bossKillBonus = 0; screenShake = 0; enemies = []; bullets = []; particles = []; powerUps = []; turrets = []; allies = []; player = new Player(); gameState = 'playing'; }
    function startOrRestartGame() {
        mainMenuScreen.style.display = 'none';
        const activeTitle = TITLES[playerStats.activeTitle];
        if (activeTitle) {
            const titleEl = document.createElement('p');
            titleEl.textContent = `"${activeTitle.name}"`;
            titleEl.style.position = 'absolute';
            titleEl.style.top = '40%';
            titleEl.style.fontSize = '1.5em';
            titleEl.style.color = 'var(--rarity-legendary)';
            titleEl.style.textShadow = '2px 2px 5px #000';
            titleEl.style.zIndex = '100';
            titleEl.style.animation = 'fade-out 2s forwards';
            gameContainer.appendChild(titleEl);
            setTimeout(() => titleEl.remove(), 2000);
        }
        resetGame();
        if (!animationFrameId) { lastTime = 0; animationFrameId = requestAnimationFrame(gameLoop); }
    }

    // --- 6. Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨ Î∞è UI ---
    function saveData() { localStorage.setItem('chronoBreakData_v12', JSON.stringify({ highScore, chronoShards, characters, upgrades, controlMode, dailyDeals, playerStats, version: 12 })); }
    
    function migrateData(data, fromVersion) {
        // Î≤ÑÏ†ÑÎ≥Ñ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Î°úÏßÅ
        if (fromVersion < 12) {
            // v12ÏóêÏÑú Ï∂îÍ∞ÄÎêú ÏÉàÎ°úÏö¥ Ï†ÅÎì§Ïóê ÎåÄÌïú ÌÇ¨ Ïπ¥Ïö¥ÌÑ∞ Ï∂îÍ∞Ä
            if (data.playerStats) {
                if (!data.playerStats.splitterKills) data.playerStats.splitterKills = 0;
                if (!data.playerStats.summonerKills) data.playerStats.summonerKills = 0;
            }
            console.log('Îç∞Ïù¥ÌÑ∞Î•º v12Î°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÌñàÏäµÎãàÎã§.');
        }
        
        // Ï∫êÎ¶≠ÌÑ∞ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
        const defaultCharacters = initializeCharacterData(characters);
        if (data.characters) {
            Object.keys(defaultCharacters).forEach(id => {
                if (!data.characters[id]) { 
                    data.characters[id] = defaultCharacters[id];
                    console.log(`ÏÉà Ï∫êÎ¶≠ÌÑ∞ ${id}Í∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.`);
                }
            });
            data.characters = initializeCharacterData(data.characters);
        } else {
            data.characters = defaultCharacters;
        }
        
        return data;
    }
    
    function loadData() {
        // ÏµúÏã† Î≤ÑÏ†Ñ Îç∞Ïù¥ÌÑ∞ ÏãúÎèÑ
        let data = JSON.parse(localStorage.getItem('chronoBreakData_v12'));
        let currentVersion = 12;
        
        if (!data) {
            // Ïù¥Ï†Ñ Î≤ÑÏ†ÑÎì§ ÏàúÏÑúÎåÄÎ°ú ÏãúÎèÑ
            const versions = ['v11', 'v10', 'v9', 'v8'];
            for (let i = 0; i < versions.length; i++) {
                const versionKey = 'chronoBreakData_' + versions[i];
                data = JSON.parse(localStorage.getItem(versionKey));
                if (data) {
                    const fromVersion = data.version || parseInt(versions[i].substring(1));
                    console.log(`v${fromVersion} Îç∞Ïù¥ÌÑ∞Î•º Î∞úÍ≤¨ÌñàÏäµÎãàÎã§. ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÏùÑ ÏãúÏûëÌï©ÎãàÎã§.`);
                    data = migrateData(data, fromVersion);
                    break;
                }
            }
            
            // ÏïÑÎ¨¥ Îç∞Ïù¥ÌÑ∞ÎèÑ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú Ï¥àÍ∏∞Ìôî
            if (!data) {
                console.log('Í∏∞Ï°¥ Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. ÏÉàÎ°ú ÏãúÏûëÌï©ÎãàÎã§.');
                data = {
                    highScore: 0,
                    chronoShards: 0,
                    controlMode: 'keyboard',
                    dailyDeals: { date: null, items: [] },
                    upgrades: upgrades,
                    characters: initializeCharacterData(characters),
                    playerStats: {
                        totalKills: 0, bossKills: 0, gamesPlayed: 0, totalScore: 0, 
                        splitterKills: 0, summonerKills: 0
                    },
                    version: 12
                };
            }
        }
        
        // NOVA BUG FIX - ONE-TIME RESET (Í∏∞Ï°¥ Î≤ÑÍ∑∏ ÏàòÏ†ï Ïú†ÏßÄ)
        if (data.characters && data.characters.nova && !data.novaBugFixed) {
            if (data.highScore === data.characters.nova.highScore) {
                data.highScore = 0;
            }
            data.characters.nova.highScore = 0;
            data.characters.nova.skins.mythic.unlocked = false;
            data.novaBugFixed = true; // Ìïú Î≤àÎßå Ïã§ÌñâÎêòÎèÑÎ°ù ÌîåÎûòÍ∑∏ Ï∂îÍ∞Ä
            console.log('Nova Î≤ÑÍ∑∏Í∞Ä ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.');
        }

        // Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        highScore = data.highScore || 0;
        chronoShards = data.chronoShards || 0;
        controlMode = data.controlMode || 'keyboard';
        dailyDeals = data.dailyDeals || { date: null, items: [] };
        upgrades = data.upgrades || upgrades;
        
        if (data.characters) {
            const loadedChars = initializeCharacterData(data.characters);
            Object.keys(characters).forEach(id => {
                if (loadedChars[id]) { Object.assign(characters[id], loadedChars[id]); }
            });
        }
        
        // playerStats ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò - ÎàÑÎùΩÎêú ÌïÑÎìú Ï∂îÍ∞Ä
        playerStats = data.playerStats || {};
        const defaultStats = {
            totalKills: 0, totalGraze: 0, maxScore: 0, maxWave: 0,
            gamesPlayed: 0, totalShardsEarned: 0, unlockedCharCount: 0,
            splitterKills: 0, summonerKills: 0, // ÏÉàÎ°úÏö¥ Ï†Å ÌÇ¨ Ïπ¥Ïö¥ÌÑ∞
            completedMissions: [], unlockedTitles: ['rookie'], activeTitle: 'rookie'
        };
        
        Object.keys(defaultStats).forEach(key => {
            if (playerStats[key] === undefined) {
                playerStats[key] = defaultStats[key];
            }
        });
        
        // Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• (ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÎêú Îç∞Ïù¥ÌÑ∞Î•º ÏµúÏã† Î≤ÑÏ†ÑÏúºÎ°ú Ï†ÄÏû•)
        saveData();
        console.log('Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏôÑÎ£å:', {
            version: data.version || 'legacy',
            highScore, 
            chronoShards, 
            charactersCount: Object.keys(characters).length
        });
    }
    function updateAllUI() {
        shardDisplays.forEach(el => el.textContent = `üíé ${chronoShards}`);
        const activeTitle = TITLES[playerStats.activeTitle];
        mainTitleDisplay.textContent = activeTitle ? `"${activeTitle.name}"` : "";
        updateHangarScreen();
        updateShopScreen();
        updateProfileScreen();
        controlToggleButton.textContent = `Ïª®Ìä∏Î°§: ${controlMode === 'keyboard' ? 'ÌÇ§Î≥¥Îìú' : 'ÌÑ∞Ïπò'}`;
    }
    function updateHangarScreen() {
        charListPanel.innerHTML = '';
        Object.keys(characters).forEach(id => { const char = characters[id]; const div = document.createElement('div'); div.className = 'char-portrait'; if (char.unlocked) { div.innerHTML = `<span class="char-icon" style="color:${SKIN_DATA[id].default.shipColor}">${char.icon}</span><div class="char-portrait-info"><span class="char-name">${char.name}</span><span class="char-highscore">HI: ${char.highScore}</span></div>`; div.onclick = () => { selectedCharacterId = id; updateHangarScreen(); }; if (id === selectedCharacterId) div.classList.add('selected'); } else { div.classList.add('locked'); div.innerHTML = `<span class="char-icon">?</span><div class="char-portrait-info"><span class="char-name">???</span></div>`; div.onclick = () => alert('Ï∫êÎ¶≠ÌÑ∞ ÎΩëÍ∏∞ÏóêÏÑú ÌöçÎìùÌï† Ïàò ÏûàÏäµÎãàÎã§.'); } charListPanel.appendChild(div); });
        const selectedCharData = characters[selectedCharacterId];
        selectedCharDetailsEl.innerHTML = `<h3>${selectedCharData.name}</h3><p><b>Í≥µÍ≤©:</b> ${selectedCharData.attackDesc}</p><p><b>ÌäπÏÑ±:</b> ${selectedCharData.specialDesc}</p>`;
        skinSelectionContainer.innerHTML = '';
        Object.keys(selectedCharData.skins).forEach(skinId => { const skinData = selectedCharData.skins[skinId]; const swatch = document.createElement('div'); swatch.className = `skin-swatch rarity-${skinId}`; swatch.style.backgroundColor = SKIN_DATA[selectedCharacterId][skinId].shipColor; if (skinData.unlocked) { if (skinId === selectedCharData.selectedSkin) swatch.classList.add('selected'); swatch.onclick = () => { selectedCharData.selectedSkin = skinId; saveData(); updateHangarScreen(); }; } else { swatch.classList.add('locked'); } skinSelectionContainer.appendChild(swatch); });
        upgradeSection.innerHTML = ''; Object.keys(upgrades).forEach(id => { const upg = upgrades[id]; const cost = upg.level < upg.maxLevel ? upg.cost[upg.level] : 'MAX'; const row = document.createElement('div'); row.className = 'upgrade-row'; row.innerHTML = `<span>${upg.name} (Lv.${upg.level})</span>`; const btn = document.createElement('button'); btn.textContent = `UP (üíé${cost})`; btn.disabled = upg.level >= upg.maxLevel || chronoShards < cost; btn.onclick = () => buyUpgrade(id); row.appendChild(btn); upgradeSection.appendChild(row); });
        const lockedChars = Object.values(characters).filter(c => !c.unlocked); charGachaButton.disabled = chronoShards < 1500 || lockedChars.length === 0;
    }
    function updateShopScreen() {
        generateDailyDeals();
        shopContentEl.innerHTML = '';
        if (dailyDeals.items.length === 0) { shopContentEl.innerHTML = '<p>Ïò§ÎäòÏùò ÏÉÅÌíàÏù¥ Î™®Îëê ÌåêÎß§ÎêòÏóàÍ±∞ÎÇò, Íµ¨Îß§ Í∞ÄÎä•Ìïú Ïä§ÌÇ®Ïù¥ ÏóÜÏäµÎãàÎã§.</p>';
        } else {
            dailyDeals.items.forEach(item => {
                const charData = characters[item.charId]; const skinData = charData.skins[item.skinId]; const skinInfo = SKIN_DATA[item.charId][item.skinId]; const isOwned = skinData.unlocked; const price = SKIN_PRICES[item.skinId];
                const itemDiv = document.createElement('div'); itemDiv.className = 'shop-item';
                const previewCanvas = document.createElement('canvas'); previewCanvas.className = 'skin-preview-canvas'; previewCanvas.width = 60; previewCanvas.height = 60;
                drawPlayerPreview(previewCanvas, item.charId, item.skinId);
                const infoDiv = document.createElement('div'); infoDiv.className = 'shop-item-info';
                infoDiv.innerHTML = `<div class="shop-item-name">${charData.name} - ${skinInfo.name}</div><div class="shop-item-rarity-${item.skinId}">${item.skinId}</div><div class="shop-item-price">üíé ${price}</div>`;
                const buyButton = document.createElement('button'); buyButton.textContent = isOwned ? 'Î≥¥Ïú†Ï§ë' : 'Íµ¨Îß§'; buyButton.disabled = isOwned || chronoShards < price; buyButton.onclick = () => buySkin(item.charId, item.skinId, price);
                itemDiv.appendChild(previewCanvas); itemDiv.appendChild(infoDiv); itemDiv.appendChild(buyButton); shopContentEl.appendChild(itemDiv);
            });
        }
        const potentialSkins = getPotentialSkins(); shopRefreshButton.disabled = chronoShards < 150 || potentialSkins.length < 5;
    }
    function updateProfileScreen() {
        updateMissionsTab(); updateTitlesTab();
    }
    function updateMissionsTab() {
        missionsTab.innerHTML = '';
        playerStats.unlockedCharCount = Object.values(characters).filter(c => c.unlocked).length;
        Object.keys(MISSIONS).forEach(id => {
            const mission = MISSIONS[id];
            const isCompleted = playerStats.completedMissions.includes(id);
            const currentVal = playerStats[mission.trackerKey] || 0;
            const progress = Math.min(currentVal / mission.target, 1);
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'mission-item';
            itemDiv.innerHTML = `<div class="mission-desc">${mission.desc}</div>
                <div class="mission-progress-bar"><div class="mission-progress-fill" style="width: ${progress * 100}%"></div></div>
                <div class="mission-reward">
                    <span>${Math.floor(currentVal)} / ${mission.target}</span>
                    <button id="claim-${id}" ${isCompleted || progress < 1 ? 'disabled' : ''}>Î≥¥ÏÉÅ (üíé${mission.reward})</button>
                </div>`;
            missionsTab.appendChild(itemDiv);
            if (!isCompleted && progress >= 1) {
                document.getElementById(`claim-${id}`).onclick = () => claimMissionReward(id);
            }
        });
    }
    function updateTitlesTab() {
        titlesTab.innerHTML = '';
        Object.keys(TITLES).forEach(id => {
            const title = TITLES[id];
            const isUnlocked = playerStats.unlockedTitles.includes(id);
            const itemDiv = document.createElement('div');
            itemDiv.className = 'title-item';
            if (isUnlocked) {
                if(playerStats.activeTitle === id) itemDiv.classList.add('selected');
                itemDiv.onclick = () => { playerStats.activeTitle = id; saveData(); updateAllUI(); };
            } else {
                itemDiv.classList.add('locked');
            }
            itemDiv.innerHTML = `<strong>${isUnlocked ? title.name : '???'}</strong><div class="title-desc">${title.desc}</div>`;
            titlesTab.appendChild(itemDiv);
        });
    }
    function getPotentialSkins() { const potential = []; Object.keys(characters).forEach(charId => { if (characters[charId].unlocked) { Object.keys(characters[charId].skins).forEach(skinId => { if (!characters[charId].skins[skinId].unlocked && SKIN_PRICES[skinId]) { potential.push({ charId, skinId }); } }); } }); return potential; }
    function generateDailyDeals(forceRefresh = false) { const today = new Date().toDateString(); if (dailyDeals.date === today && !forceRefresh) return; const potentialSkins = getPotentialSkins(); for (let i = potentialSkins.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [potentialSkins[i], potentialSkins[j]] = [potentialSkins[j], potentialSkins[i]]; } const newDeals = potentialSkins.slice(0, 5); dailyDeals = { date: today, items: newDeals }; saveData(); }
    function refreshShop() { const cost = 150; if (chronoShards >= cost) { chronoShards -= cost; playSound('itemGet'); generateDailyDeals(true); updateAllUI(); } else { alert(`ÏÉ§ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. (ÌïÑÏöî: üíé${cost})`); } }
    function drawPlayerPreview(targetCanvas, charId, skinId) {
        const pCtx = targetCanvas.getContext('2d'); pCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
        const skin = SKIN_DATA[charId][skinId]; const char = { x: targetCanvas.width / 2, y: targetCanvas.height / 2, size: 15, color: skin.shipColor, geometry: SKIN_GEOMETRY[skin.geometry] || SKIN_GEOMETRY.default };
        pCtx.fillStyle = char.color; pCtx.beginPath(); char.geometry.forEach((p, i) => { const xPos = char.x + p.x * char.size; const yPos = char.y + p.y * char.size; if (i === 0) pCtx.moveTo(xPos, yPos); else pCtx.lineTo(xPos, yPos); }); pCtx.closePath(); pCtx.fill();
    }
    function buyUpgrade(id) { const upg = upgrades[id]; const cost = upg.cost[upg.level]; if (chronoShards >= cost && upg.level < upg.maxLevel) { chronoShards -= cost; upg.level++; playSound('itemGet'); saveData(); updateAllUI(); } }
    function buyCharacterGacha() { const cost = 1500; if (chronoShards >= cost) { const locked = Object.keys(characters).filter(id => !characters[id].unlocked); if (locked.length > 0) { chronoShards -= cost; const unlockedId = locked[Math.floor(Math.random() * locked.length)]; characters[unlockedId].unlocked = true; alert(`‚ú® [Ï∫êÎ¶≠ÌÑ∞ Ìï¥Í∏à] ${characters[unlockedId].name} ÌöçÎìù! ‚ú®`); playSound('itemGet', 1.0); saveData(); updateAllUI(); } else { alert('Î™®Îì† Ï∫êÎ¶≠ÌÑ∞Î•º Ìï¥Í∏àÌñàÏäµÎãàÎã§!'); } } else { alert(`ÏÉ§ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. (ÌïÑÏöî: üíé${cost})`); } }
    function buySkin(charId, skinId, price) { if (chronoShards >= price) { chronoShards -= price; characters[charId].skins[skinId].unlocked = true; alert(`‚ú® [Ïä§ÌÇ® Íµ¨Îß§] ${characters[charId].name} - ${SKIN_DATA[charId][skinId].name} Ïä§ÌÇ®ÏùÑ Íµ¨Îß§ÌñàÏäµÎãàÎã§! ‚ú®`); playSound('itemGet', 1.0); checkUnlocks(); saveData(); updateAllUI(); } }
    function claimMissionReward(missionId) {
        const mission = MISSIONS[missionId];
        if (mission && !playerStats.completedMissions.includes(missionId)) {
            chronoShards += mission.reward;
            playerStats.completedMissions.push(missionId);
            playSound('itemGet', 1.2);
            alert(`ÎØ∏ÏÖò ÏôÑÎ£å! üíé${mission.reward} ÌöçÎìù!`);
            checkUnlocks();
            saveData();
            updateAllUI();
        }
    }
    function checkUnlocks() {
        let newUnlock = false;
        Object.keys(TITLES).forEach(id => {
            if (!playerStats.unlockedTitles.includes(id)) {
                const title = TITLES[id];
                let shouldUnlock = false;
                if (title.requiresMission) {
                    if (playerStats.completedMissions.includes(title.requiresMission)) {
                        shouldUnlock = true;
                    }
                } else if (title.requiresMythic) {
                    if (Object.values(characters).some(c => c.skins.mythic.unlocked)) {
                        shouldUnlock = true;
                    }
                }
                if (shouldUnlock) {
                    playerStats.unlockedTitles.push(id);
                    alert(`Ïπ≠Ìò∏ ÌöçÎìù: ${title.name}!`);
                    newUnlock = true;
                }
            }
        });
        if (newUnlock) saveData();
    }

    // --- 7. Ï¥àÍ∏∞Ìôî ---
    function init() {
        function resizeCanvas() { const aspectRatio = 9 / 16; let newWidth = window.innerWidth, newHeight = window.innerHeight; const windowRatio = newWidth / newHeight; if (windowRatio > aspectRatio) { newHeight = Math.min(newHeight, 1200); newWidth = newHeight * aspectRatio; } else { newWidth = Math.min(newWidth, 800); newHeight = newWidth / aspectRatio; } canvas.width = newWidth; canvas.height = newHeight; const scale = newWidth / 450; document.body.style.fontSize = `${scale}rem`; backgroundStars = []; for(let i=0; i<100; i++) { backgroundStars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 1, speed: Math.random() * 20 + 10, opacity: Math.random() * 0.5 + 0.2 }); } }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();
        const rootStyles = getComputedStyle(document.documentElement);
        colors.enemy1 = rootStyles.getPropertyValue('--enemy-color-1').trim(); colors.enemy2 = rootStyles.getPropertyValue('--enemy-color-2').trim(); colors.dasher = rootStyles.getPropertyValue('--enemy-dasher-color').trim(); colors.weaver = rootStyles.getPropertyValue('--enemy-weaver-color').trim(); colors.kamikaze = rootStyles.getPropertyValue('--enemy-kamikaze-color').trim(); colors.boss = rootStyles.getPropertyValue('--boss-color').trim(); colors.enemyBullet = rootStyles.getPropertyValue('--enemy-bullet-color').trim();
        colors.powerupP = rootStyles.getPropertyValue('--powerup-p-color').trim(); colors.powerupB = rootStyles.getPropertyValue('--powerup-b-color').trim(); colors.powerupC = rootStyles.getPropertyValue('--powerup-c-color').trim(); colors.powerupS = rootStyles.getPropertyValue('--powerup-s-color').trim();
        colors.sentinel = rootStyles.getPropertyValue('--enemy-sentinel-color').trim(); colors.bulwark = rootStyles.getPropertyValue('--enemy-bulwark-color').trim(); colors.barrier = rootStyles.getPropertyValue('--enemy-barrier-color').trim();
        colors.splitter = rootStyles.getPropertyValue('--enemy-splitter-color').trim(); colors.summoner = rootStyles.getPropertyValue('--enemy-summoner-color').trim();
        colors.inhibitor = rootStyles.getPropertyValue('--enemy-inhibitor-color').trim(); colors.split = rootStyles.getPropertyValue('--enemy-split-color').trim(); colors.hunter = rootStyles.getPropertyValue('--enemy-hunter-color').trim();
        
        loadData(); 

        // DEBUG: Unlock all characters and skins
        const isDebug = false; // DEBUG MODE OFF
        if (isDebug) {
            Object.values(characters).forEach(char => {
                char.unlocked = true;
                if (char.skins) {
                    Object.values(char.skins).forEach(skin => {
                        skin.unlocked = true;
                    });
                }
            });
            chronoShards = 999999; // Set a large amount of shards for testing
            console.log("DEBUG MODE: All characters, skins, and 999999 shards have been unlocked.");
        }
        
        updateAllUI(); 
        initAudio();
        
        // ÏóÖÎç∞Ïù¥Ìä∏ ÏïåÎ¶º ÌëúÏãú
        showUpdateNotification();
        
        startGameButton.onclick = async () => { if (audioContext && audioContext.state === 'suspended') { await audioContext.resume(); } inputHandler.setup(); startOrRestartGame(); };
        charGachaButton.onclick = buyCharacterGacha;
        controlToggleButton.onclick = () => { controlMode = (controlMode === 'keyboard') ? 'touch' : 'keyboard'; saveData(); updateAllUI(); };
        returnToMenuButton.onclick = () => { gameOverScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; updateAllUI(); };
        
        hangarButton.onclick = () => { mainMenuScreen.style.display = 'none'; hangarScreen.style.display = 'flex'; updateHangarScreen(); };
        shopButton.onclick = () => { mainMenuScreen.style.display = 'none'; shopScreen.style.display = 'flex'; updateShopScreen(); };
        profileButton.onclick = () => { mainMenuScreen.style.display = 'none'; profileScreen.style.display = 'flex'; updateProfileScreen(); };
        shopRefreshButton.onclick = refreshShop;
        backToMenuFromHangarBtn.onclick = () => { hangarScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; };
        backToMenuFromShopBtn.onclick = () => { shopScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; };
        backToMenuFromProfileBtn.onclick = () => { profileScreen.style.display = 'none'; mainMenuScreen.style.display = 'flex'; };
        missionsTabBtn.onclick = () => { missionsTab.classList.add('active'); titlesTab.classList.remove('active'); missionsTabBtn.classList.add('active'); titlesTabBtn.classList.remove('active'); };
        titlesTabBtn.onclick = () => { missionsTab.classList.remove('active'); titlesTab.classList.add('active'); missionsTabBtn.classList.remove('active'); titlesTabBtn.classList.add('active'); };

        highScoreEl.textContent = `HIGH: ${Math.floor(highScore)}`;
    }
    
    function showUpdateNotification() {
        const currentVersion = 12;
        const lastSeenVersion = parseInt(localStorage.getItem('lastSeenVersion')) || 0;
        
        if (lastSeenVersion < currentVersion) {
            localStorage.setItem('lastSeenVersion', currentVersion.toString());
            
            // Î≤ÑÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÎÇ¥Ïö©
            const updateNotes = {
                12: [
                    'üî• ÏÉàÎ°úÏö¥ Ï†Å: Î∂ÑÏó¥Ï≤¥ (Ïõ®Ïù¥Î∏å 10+)',
                    '‚ú® ÏÉàÎ°úÏö¥ Ï†Å: ÏÜåÌôòÏà†ÏÇ¨ (Ïõ®Ïù¥Î∏å 12+)', 
                    'üõ†Ô∏è Îç∞Ïù¥ÌÑ∞ Ìò∏ÌôòÏÑ± Í∞úÏÑ†',
                    'üìä ÏÉàÎ°úÏö¥ ÌÜµÍ≥Ñ Ï∂îÍ∞Ä'
                ]
            };
            
            if (lastSeenVersion > 0) {
                console.log('üéâ ÌÅ¨Î°úÎÖ∏ Î∏åÎ†àÏù¥ÌÅ¨ v1.2 ÏóÖÎç∞Ïù¥Ìä∏!');
                console.log('ÏÉàÎ°úÏö¥ Í∏∞Îä•:');
                updateNotes[currentVersion]?.forEach(note => console.log('  ' + note));
            }
        }
        
        // Î≤ÑÏ†Ñ Ï†ïÎ≥¥Î•º Î©îÏù∏ ÌôîÎ©¥Ïóê ÌëúÏãú
        const versionInfo = document.createElement('div');
        versionInfo.style.cssText = `
            position: absolute; 
            bottom: 10px; 
            right: 15px; 
            font-size: 0.6em; 
            color: #666; 
            pointer-events: none;
        `;
        versionInfo.textContent = 'v1.2';
        mainMenuScreen.appendChild(versionInfo);
    }
    
    window.addEventListener('load', init);
    </script>
</body>
</html>
